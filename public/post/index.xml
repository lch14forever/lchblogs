<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chenhao&#39;s Personal Page</title>
    <link>/post/</link>
    <description>Recent content in Posts on Chenhao&#39;s Personal Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© This site was created with R BlogDown and HuGo by Chenhao Li.</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0800</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-II 主函数和输入输出</title>
      <link>/post/2019-09-29-nextflow-main/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-09-29-nextflow-main/</guid>
      <description>&lt;div id=&#34;nextflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;第一个Nextflow程序&lt;/h2&gt;
&lt;p&gt;创建以下名为main.nf的Nextflow文件&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow

// DSL 2 syntax
nextflow.preview.dsl=2

// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;

// help message
def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}

// Create channel for reads
ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

ch_reads.view()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;逐行解析&lt;/h2&gt;
&lt;div id=&#34;shebang&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Shebang&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同很多Unix-like脚本一样，第一行叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_(Unix)&#34;&gt;“shebang” (Hash bang)&lt;/a&gt;，出现在脚本第一行并以&lt;code&gt;#!&lt;/code&gt;开头。它告诉系统用什么环境软件去解析这个脚本，当它存在并且脚本可执行的时候，我们可以通过直接调用该脚本来运行程序。以下为示例：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;通过Interpreter来调用脚本（shebang不存在时也可使用）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;nextflow run ./main.nf&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;直接调用（需要shebang）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;chmod u+x ./main.nf ## 添加可执行权限
./main.nf           ## 系统自动使用nextflow运行&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dsl2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;使用DSL2语言&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;nextflow.preview.dsl=2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：DSL2是新功能，后续语法可能会调整&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;流程参数&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nextflow通过params这个字典来允许执行时直接传入参数。上述的两个参数&lt;code&gt;help&lt;/code&gt;，和&lt;code&gt;read_path&lt;/code&gt;，在命令行中可通过&lt;code&gt;--help&lt;/code&gt;，&lt;code&gt;--read_path /PATH/TO/READS&lt;/code&gt;，来更改。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;./main.nf --help ## 将params.help的值更改为true
./main.nf --read_path /data/reads/ ## 将params.read_path的值更改为~/reads&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;groovy&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Groovy原生支持&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nextflow基于Groovy语言，可在流程中直接使用。以上部分定义了函数&lt;code&gt;helppMessage&lt;/code&gt;，在接到&lt;code&gt;--help&lt;/code&gt;输入时会输出帮助文档并退出执行。&lt;code&gt;workflow&lt;/code&gt;为Nextflow定义的特殊字典，&lt;code&gt;${workflow.projectDir}&lt;/code&gt;对应了当前脚本(&lt;code&gt;main.nf&lt;/code&gt;)的目录。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ./main.nf --help
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [distraught_meitner] - revision: bb88634790
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
=================================================================
Usage: /home/ubuntu/shotgunmetagenomics-nf/tutorial/main.nf --read_path PATH/OF/READS
=================================================================&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;channel&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Channel&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

ch_reads.view()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Netflow定义了Channel，通过Channel来在不同过程(Process)之间传递文件。Channel保证了基于不同文件的运算独立、并行进行。Channel对应的文件会被“拷贝”(经常以symbolic link的形式)到&lt;code&gt;work/&lt;/code&gt;目录下。这个定义其实不是很容易说得清楚，建议阅读Nextflow&lt;a href=&#34;https://www.nextflow.io/docs/latest/channel.html&#34;&gt;帮助文档&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fromFilePair&lt;/code&gt;专门为fastq打造，可以直接将不同的样本以列表形式分组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;/**{1,2}.f*q*&#39;&lt;/code&gt;定义了文件匹配方式，&lt;code&gt;**&lt;/code&gt;表示递归地检索文件，&lt;code&gt;{1,2}.f*q*&lt;/code&gt;跟bash本身的文件匹配一致，这里会匹配结尾为&lt;code&gt;1.fastq.gz&lt;/code&gt;，&lt;code&gt;2.fastq&lt;/code&gt;，&lt;code&gt;1.fq&lt;/code&gt;，&lt;code&gt;2.fq.gz&lt;/code&gt;的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flat: ture&lt;/code&gt;使返回的双端序列和匹配ID存储为一个列表中。下面是一个例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls /data/reads/
SRR1950772_1.fastq.gz  SRR1950772_2.fastq.gz  SRR1950773_1.fastq.gz  SRR1950773_2.fastq.gz

$ ./main.nf --read_path /data/reads/
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [elegant_volta] - revision: bb88634790
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
[SRR1950773, /data/reads/SRR1950773_1.fastq.gz, /data/reads/SRR1950773_2.fastq.gz]
[SRR1950772, /data/reads/SRR1950772_1.fastq.gz, /data/reads/SRR1950772_2.fastq.gz]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果默认情况 (&lt;code&gt;flat: false&lt;/code&gt;)使用&lt;code&gt;.fromFilePairs(params.read_path + &#39;/**{1,2}.f*q*&#39;)&lt;/code&gt;，输出结果会将Read1和Read2合并在一个列表中：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;[SRR1950773, [/data/reads/SRR1950773_1.fastq.gz, /data/reads/SRR1950773_2.fastq.gz]]
[SRR1950772, [/data/reads/SRR1950772_1.fastq.gz, /data/reads/SRR1950772_2.fastq.gz]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://www.nextflow.io/docs/latest/&#34; class=&#34;uri&#34;&gt;https://www.nextflow.io/docs/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-I 安装Nextflow</title>
      <link>/post/2019-09-27-nextflow-install/</link>
      <pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-09-27-nextflow-install/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;开一个坑&lt;/h2&gt;
&lt;p&gt;本系列介绍如何搭建基于Nextflow的宏基因组有参分析流程。在此之前我曾经使用bpipe和snakemake写过这个&lt;a href=&#34;https://github.com/lch14forever/shotgun-metagenomics-pipeline&#34;&gt;流程&lt;/a&gt;。在我们实验室中所有的有参分析都是这个pipeline跑出来的。个人感觉bpipe用起来其实很顺手自然，但是由于社区实在是不够活跃。snakemake基于python而且有很多开发者支持，所以为了学习snakemake，我将之前的流程重新写成了snakemake。但是后来渐渐发现make的这种从后向前结构很别扭，基于文件名构建DAG也是缺乏灵活性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nextflow.io/&#34;&gt;Nextflow&lt;/a&gt;作为后起之秀迅速成长，拥有很好的社区支持（&lt;a href=&#34;https://groups.google.com/forum/#!forum/nextflow&#34;&gt;google group&lt;/a&gt;，&lt;a href=&#34;https://gitter.im/nextflow-io/nextflow&#34;&gt;gitter&lt;/a&gt;），原生对云环境（AWS，google cloud）支持，拥有大量优秀成熟流程&lt;a href=&#34;https://github.com/nf-core&#34;&gt;nf-core&lt;/a&gt;。最近的一次更新推出了模块化的&lt;a href=&#34;https://www.nextflow.io/blog/2019/one-more-step-towards-modules.html&#34;&gt;DSL 2架构&lt;/a&gt;，构建可重复利用的流程未来可期。为了更好地学习Nextflow，我将把之前的shotgunMetagenomics流程重写，并把过程记录下来，也希望可以帮助到更多人。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;流程介绍&lt;/h2&gt;
&lt;p&gt;这个流程可以参见snakemake生成的DAG:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/lch14forever/shotgun-metagenomics-pipeline/raw/master/snakemake_pipeline/work_flow.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;步骤为：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;合并相同样本&lt;/li&gt;
&lt;li&gt;去接头&lt;/li&gt;
&lt;li&gt;去宿主DNA&lt;/li&gt;
&lt;li&gt;使用Profiling工具（kraken2，MetaPhlAn2）&lt;/li&gt;
&lt;li&gt;按系统分类拆分&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;## 安装Nextflow&lt;/p&gt;
&lt;p&gt;依赖：java &amp;gt;= 1.8&lt;/p&gt;
&lt;p&gt;稳定版本安装：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;curl -s https://get.nextflow.io | bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Github开发版本安装，支持DSL2语法：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;git clone https://github.com/nextflow-io/nextflow.git

cd nextflow

make compile

make pack&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的Nextflow在&lt;code&gt;build/releases/nextflow-19.09.0-edge-all&lt;/code&gt;，可以重新命名为&lt;code&gt;nextflow&lt;/code&gt;并放在&lt;code&gt;$PATH&lt;/code&gt;中。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;export PATH=$PATH:/PATH/TO/REPO/build/releases/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>启动Conda环境时自动更改环境变量</title>
      <link>/post/2019-08-17-conda-activate/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-17-conda-activate/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;这是一个神奇的路径&lt;/h2&gt;
&lt;p&gt;我们在服务器上用conda创建了一个叫&lt;code&gt;metagenomics&lt;/code&gt;的环境，希望将常用分析软件安装在该环境。其中一些软件需要使用新版本的gcc编译（如：kraken2）。安装的准备套路应该如下：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;export PATH=/opt/gcc-4.9.3/bin/:$PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64/:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如果我希望以上环境变量仅对我特定的Conda环境起效（&lt;code&gt;metagenomics&lt;/code&gt;）应该怎么办呢？我们需要像.bashrc (.bash_profile)和.bash_logout这样在环境activate和deactivate时自动执行的脚本。在Conda中，我们需要如下目录：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;ANACONDA_PATH/envs/ENV_PATH/etc/conda/
├── activate.d        
│   └── env_vars.sh   ## &amp;lt;- sourced when you do `conda activate`
└── deactivate.d     
    └── env_vars.sh   ## &amp;lt;- sourced when you do `conda deactivate`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下的就是shell脚本的编写了，在下面的例子中，我们创建了一个叫做metagenomics的环境，并在其中安装了metaphlan2，kraken2，strainphlan。&lt;/p&gt;
&lt;div id=&#34;activate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;activate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

## CANU
export OLD_PATH=$PATH
export PATH=$(echo $PATH | sed &amp;#39;s;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/utils/:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/strainphlan_src/:;&amp;#39;)
export R_LIBS=/mnt/software/unstowable/anaconda/envs/metagenomics/lib/R/library
export BOWTIE2_INDEXES=/mnt/genomeDB/misc/softwareDB/metaphlan/huttenhower.sph.harvard.edu/metaphlan/bowtie2db/

## Kraken2
export OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;deactivate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;deactivate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

export PATH=$OLD_PATH
export R_LIBS=
export BOWTIE2_INDEXES=
export LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在旧版的Anaconda中，&lt;code&gt;source deactivate&lt;/code&gt;默认会把&lt;code&gt;PATH&lt;/code&gt;变量中的第一个目录删掉，所以上面使用了&lt;code&gt;sed&lt;/code&gt;来把新目录插到第二个的位置。现在的conda版本(使用&lt;code&gt;conda deactivate&lt;/code&gt;)好像不存在这样的问题了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&#34; class=&#34;uri&#34;&gt;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Emacs远程连接R</title>
      <link>/post/2018-11-25-emacs-remote-r/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-11-25-emacs-remote-r/</guid>
      <description>&lt;section id=&#34;r&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;本地的R脚本，远程执行&lt;/h2&gt;
&lt;p&gt;从事生信工作，已经形成了对R语言的重度依赖，Rstudio作为专注于R的IDE拥有强大的优势，但是我还是更习惯于Emacs的ESS的操作。其实之前就遇到过一个挺有意思的问题，如何用本地的Emacs去编辑并执行服务器上的R脚本。一个很显而易见的方法就是用Emacs的Tramp SSH连接到服务器，打开R脚本，这个时候ESS会自动使用远程服务器的R来运行。但是问题来了，在画图的时候这个远程的R进程并不能通过X11把图传回，所以会自动存储为Rplot.pdf于工作目录。Google了很久，找到了以解决方案：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;打开本地shell/eshell (M-x shell/eshell)&lt;/li&gt;
&lt;li&gt;在打开的shell中连接远程服务器（ssh -X &lt;a href=&#34;mailto:user@remote.machine.ip&#34;&gt;user@remote.machine.ip&lt;/a&gt; 或 ssh -Y）并运行R&lt;/li&gt;
&lt;li&gt;使用ESS remote（M-x ess-remote）&lt;/li&gt;
&lt;li&gt;打开本地或远程（Tramp mode）的R脚本&lt;/li&gt;
&lt;li&gt;使用C-c C-n（在CUA mode关闭情况下可使用C-Enter）或C-c C-c逐行或区域执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述过程中，顺序其实不是很重要，唯一需要注意的是如果R脚本在服务器上，一定要先开启一个本地的shell，要不然Emacs会默认使用远程机器的shell。&lt;/p&gt;
&lt;p&gt;为了简化此过程，我写了一个函数并把它定义给快捷键C-c C-r（写在init.el或.emacs文件中）：&lt;/p&gt;
&lt;pre class=&#34;lisp&#34;&gt;&lt;code&gt;(defun spawn-ess-remote (login)
  &amp;quot;connect to remote server and open ssh&amp;quot;
  (interactive &amp;quot;sUser login (uname@server.ip): &amp;quot;)
  (pop-to-buffer (get-buffer-create (generate-new-buffer-name &amp;quot;Remote-R&amp;quot;)))
  (shell (current-buffer))
  (process-send-string nil (format&amp;quot;ssh -Y %s \n&amp;quot; login) )
  (process-send-string nil &amp;quot;R\n&amp;quot;)
  (ess-remote nil &amp;quot;R&amp;quot;))
(global-set-key (kbd &amp;quot;C-c C-r&amp;quot;) &amp;#39;spawn-ess-remote)
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Frequently Googled Questions</title>
      <link>/post/2018-09-05-bioinfo-cheatsheet/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-09-05-bioinfo-cheatsheet/</guid>
      <description>&lt;div id=&#34;linux&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Linux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Extract (decompress) with a file pattern (wildcard) &lt;a href=&#34;https://superuser.com/questions/504798/extract-specific-files-in-a-tar-archive-using-a-wildcard&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;tar -xf MyTar.tar --wildcards &amp;quot;*.jpg&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;ggplot2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rotate axis label &lt;a href=&#34;https://stackoverflow.com/questions/1330989/rotating-and-spacing-axis-labels-in-ggplot2&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;remove legend title &lt;a href=&#34;http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/#hiding-the-legend-title&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Remove title for fill legend
p + 
  guides(fill=guide_legend(title=NULL))

# Remove title for all legends
p + 
  theme(legend.title=element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;legends in multiple columns/rows &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/guide_legend.html&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A lot of interesting and useful things in this ref&lt;/li&gt;
&lt;li&gt;overriding the alpha value&lt;/li&gt;
&lt;li&gt;customizing the legend text angle&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  guides(col = guide_legend(nrow = 8))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>一（三）文你读不懂PCA和PCoA</title>
      <link>/post/2018-04-39-r-pca_pcoa/</link>
      <pubDate>Mon, 30 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-04-39-r-pca_pcoa/</guid>
      <description>&lt;div id=&#34;pcapcoa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;三文读懂PCA和PCoA？&lt;/h2&gt;
&lt;p&gt;今天看到金唯智公众号的推文《三文读懂PCA和PCoA》（《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9e.html&#34;&gt;一&lt;/a&gt;》,《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9f.html&#34;&gt;二&lt;/a&gt;》,《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9h.html&#34;&gt;三&lt;/a&gt;》)。作者以平民化的语言，剔除数学术语，介绍了二者的区别，是很好的尝试，但是文中提出的很多关键性总结，都存在着明显的漏洞。&lt;/p&gt;
&lt;p&gt;特别指出在第二篇文章中：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;PCA基于物种丰度矩阵就意味着PCA分析的矩阵维度是就等于物种数目&lt;/strong&gt;。换句话说，你要分析的样本如果要做PCA分析，那么一般来说有多少个物种就有多少个维度”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然说到丰度，那有一个很容易忽视的点，就是所有物种丰度相加为常数（1或100%），所以说数据的维数其实是物种数-1。而相对丰度其实并不在传统意义的欧式空间中（参见Aitchison的《The Statistical Analysis of Compositional Data》）。PCA涉及到的变换其实是会保持数据点之间欧式距离不变（考虑所有PC的话），那么PCA分析是否适用于丰度（成分）数据，是一个存在争议的课题（参见Aitchison的《Principal Component Analysis of Compositional Data》）。所以在成分数据（测序数据，特别是microbiome）数据的时候，我们常采用一些生态距离，然后做PCoA。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“同样的道理，&lt;strong&gt;PCoA基于样本间的距离矩阵就意味着PCoA分析的矩阵维度与样本数目相关&lt;/strong&gt;。如果你要分析的样本做PCoA分析的话，那么一般来说有n个样本就至多有n-1个维度”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个n（样本数目）和p（维度）的问题，维度就是维度，p就是p，不能混淆。&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;多数情况下，我们在做降维处理的时候，期望维数越低越好，这样我们就可以最大程度地保真原始数据&lt;/strong&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;天下没有免费的午餐，维数越低，保真度自然越低。而PCA、PCoA所做的是在低维空间中尽量多的保存数据之间的差异。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;如果样本数目比较多，而物种数目比较少，那肯定首选PCA；如果样本数目比较少，而物种数目比较多，那肯定首选PCoA&lt;/strong&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个很有意思的问题，其实PCoA和PCA的结果取决于PCoA的实现，但是直觉上想，既然PCA的变换会保存数据点间的欧氏距离，那么它和基于欧式距离的PCoA有什么区别呢？&lt;/p&gt;
&lt;p&gt;下面做一个实验，我们用两组数据（样本数目&amp;gt;维度，纬度&amp;gt;样本数目）来看看R中常见的PCA和PCoA实现的结果有何不同。&lt;/p&gt;
&lt;div id=&#34;iris&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;iris：样本数目&amp;gt;维度&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Low dimensional data (n&amp;gt;&amp;gt;p)
data(iris)
par(mfrow=c(2,2),cex=0.7, pch=19)
## PCA
pca &amp;lt;- prcomp(iris[,-5])
plot(pca$x[,1:2], col=iris[,5], xlab=&amp;#39;PC1&amp;#39;,ylab=&amp;#39;PC2&amp;#39;, main=&amp;#39;PCA&amp;#39;)
## PCoA
pcoa &amp;lt;- cmdscale(dist(iris[,-5], method = &amp;quot;euclidean&amp;quot;))
plot(pcoa, xlab=&amp;#39;MDS1&amp;#39;,ylab=&amp;#39;MDS2&amp;#39;, col=iris[,5], main=&amp;#39;PCoA&amp;#39;)
## pairwise distances
plot(as.vector(dist(pca$x[,1:2])), as.vector(dist(pcoa)), 
     xlab=&amp;#39;PCA&amp;#39;, ylab=&amp;#39;PCoA&amp;#39;, main=&amp;#39;Pairwise distances&amp;#39;,
     pch=19, col=rgb(0,0,0,0.3), cex=0.5)
plot(as.vector(dist(pca$x[,1:2])) - as.vector(dist(pcoa)),
     main=&amp;#39;Difference in pairwise distances&amp;#39;, ylab=&amp;#39;Delta&amp;#39;,
     cex=0.5, col=rgb(0,0,0,0.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-39-r-pca_pcoa_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;gene-expression-dataset&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Gene expression dataset：维度&amp;gt;样本数目&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## High dimensional data (p&amp;gt;&amp;gt;n)
## source(&amp;quot;http://bioconductor.org/biocLite.R&amp;quot;)
## biocLite(&amp;quot;hopach&amp;quot;)
suppressMessages(library(hopach))
par(mfrow=c(2,2),cex=0.7, pch=19)
data(golub)
pca &amp;lt;- prcomp(t(golub))
plot(pca$x[,1:2], col=golub.cl+1, xlab=&amp;#39;PC1&amp;#39;,ylab=&amp;#39;PC2&amp;#39;, main=&amp;#39;PCA&amp;#39;)
pcoa &amp;lt;- cmdscale(dist(t(golub), method = &amp;quot;euclidean&amp;quot;))
plot(pcoa, xlab=&amp;#39;MDS1&amp;#39;,ylab=&amp;#39;MDS2&amp;#39;, col=golub.cl+1, main=&amp;#39;PCoA&amp;#39;)
plot(as.vector(dist(pca$x[,1:2])), as.vector(dist(pcoa)), 
     xlab=&amp;#39;PCA&amp;#39;, ylab=&amp;#39;PCoA&amp;#39;, main=&amp;#39;Pairwise distances&amp;#39;,
     pch=19, col=rgb(0,0,0,0.3), cex=0.5)
plot(as.vector(dist(pca$x[,1:2])) - as.vector(dist(pcoa)),
     main=&amp;#39;Difference in pairwise distances&amp;#39;, ylab=&amp;#39;Delta&amp;#39;,
     cex=0.5, col=rgb(0,0,0,0.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-39-r-pca_pcoa_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;很明显，在基于欧氏距离的&lt;code&gt;cmdscale&lt;/code&gt;和PCA在前两个维度上并没有什么区别。我个人一度以为PCA和基于欧式距离的PCoA其实是等同的，但是后来我们在一些PCoA的实现中确实看到了和PCA结果的差异，但是其实这个差异并不是很大。网上其实有很多的讨论，比如&lt;a href=&#34;https://stats.stackexchange.com/questions/14002/whats-the-difference-between-principal-component-analysis-and-multidimensional&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Generating GraPhlAn-like microbiome visualization using ggtree and microbiomeViz</title>
      <link>/post/2018-04-20-r-microbiomeviz_example/</link>
      <pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-04-20-r-microbiomeviz_example/</guid>
      <description>&lt;section id=&#34;data-downloading-and-preprocessing&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Data downloading and preprocessing&lt;/h3&gt;
&lt;p&gt;Now let’s try to generate a figure like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bitbucket.org/nsegata/metaphlan/wiki/lefse_biomarkers_cladogram.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sample processed by MetaPhlAn:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/nsegata/metaphlan/wiki/profiled_samples.tar.bz2&#34; class=&#34;uri&#34;&gt;https://bitbucket.org/nsegata/metaphlan/wiki/profiled_samples.tar.bz2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Script to merge samples:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/nsegata/metaphlan/raw/2f1b17a1f4e9775fe1ce42c8481279a5e69f291f/utils/merge_metaphlan_tables.py&#34; class=&#34;uri&#34;&gt;https://bitbucket.org/nsegata/metaphlan/raw/2f1b17a1f4e9775fe1ce42c8481279a5e69f291f/utils/merge_metaphlan_tables.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Merge files into a single table&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;python merge_metaphlan_tables.py profiled_samples/*.txt &amp;gt; profiled_samples/merged_abundance_table.txt&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;now-switch-to-r&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Now switch to R&lt;/h3&gt;
&lt;section id=&#34;load-data-and-library&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Load data and library&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- read.table(&amp;quot;~/Downloads/profiled_samples/merged_abundance_table.txt&amp;quot;, head=TRUE, stringsAsFactors = FALSE)
df &amp;lt;- df[,-ncol(df)]
## Use row means as a proxy for node size
dat &amp;lt;- data.frame(V1=df[,1], V2=rowMeans(df[,-1]), stringsAsFactors = FALSE)

library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;parse-data-and-create-a-backbone&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Parse data and create a backbone&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tr &amp;lt;- parseMetaphlanTSV(dat, node.size.offset=2, node.size.scale=0.8)
p &amp;lt;- tree.backbone(tr, size=0.5)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-20-r-microbiomeviz_example_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;hard-coded-lefse-results&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Hard-coded lefse results&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lefse_lists = data.frame(node=c(&amp;#39;s__Haemophilus_parainfluenzae&amp;#39;,&amp;#39;p__Proteobacteria&amp;#39;,
                              &amp;#39;f__Veillonellaceae&amp;#39;,&amp;#39;o__Selenomonadales&amp;#39;,
                              &amp;#39;c__Negativicutes&amp;#39;, &amp;#39;s__Streptococcus_parasanguinis&amp;#39;,

                              &amp;#39;p__Firmicutes&amp;#39;,&amp;#39;f__Streptococcaceae&amp;#39;,
                              &amp;#39;g__Streptococcus&amp;#39;,&amp;#39;o__Lactobacillales&amp;#39;,
                              &amp;#39;c__Bacilli&amp;#39;,&amp;#39;s__Streptococcus_mitis&amp;#39;),
                         color=c(rep(&amp;#39;darkgreen&amp;#39;,6), rep(&amp;#39;red&amp;#39;,&amp;#39;6&amp;#39;)),
                         stringsAsFactors = FALSE
                         )&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;annotate-the-tree&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Annotate the tree&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p &amp;lt;- clade.anno(p, lefse_lists, alpha=0.3)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-20-r-microbiomeviz_example_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Y叔的新包base2grob</title>
      <link>/post/2018-03-29-r-base2grob_igraph/</link>
      <pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-03-29-r-base2grob_igraph/</guid>
      <description>&lt;p&gt;测试了一下Y叔的新包&lt;a href=&#34;https://cran.r-project.org/web/packages/base2grob/vignettes/base2grob.html&#34;&gt;base2grob&lt;/a&gt;。这个包提供了base2grob函数，可以把base plot转换成grob对象。对于我来说最大的方便就是可以把一些igraph画出的网络图通过cowplot和其他ggplot做出的图自由组合。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(base2grob)
library(igraph)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;igraph&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:stats&amp;#39;:
## 
##     decompose, spectrum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:base&amp;#39;:
## 
##     union&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(cowplot)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: ggplot2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;cowplot&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:ggplot2&amp;#39;:
## 
##     ggsave&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g1 &amp;lt;- erdos.renyi.game(10, 0.2)
g2 &amp;lt;- erdos.renyi.game(10, 0.5)

E(g1)$width &amp;lt;- E(g2)$width &amp;lt;- 5
E(g1)$label.cex &amp;lt;- E(g2)$label.cex &amp;lt;- 1e-16 ## 这个我承认有点傻，但是没有找到更好的方法
V(g1)$color &amp;lt;- &amp;#39;cyan&amp;#39;
V(g2)$color &amp;lt;- &amp;#39;green&amp;#39;

p1 &amp;lt;- base2grob(~plot(g1))
p2 &amp;lt;- base2grob(~plot(g2))

plot_grid(p1, p2, labels=LETTERS[1:2])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-03-29-r-base2grob_igraph_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microbiomeViz--斜体显示taxon name</title>
      <link>/post/2018-02-01-r-metagenomeviz-italictaxon/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-02-01-r-metagenomeviz-italictaxon/</guid>
      <description>&lt;p&gt;微生物种名属名经常需要&lt;em&gt;&lt;code&gt;斜体&lt;/code&gt;&lt;/em&gt;表示，现在microbiomeViz添加了一个生成&lt;code&gt;expression&lt;/code&gt;的函数，可以直接将一个短语中的&lt;strong&gt;一个&lt;/strong&gt;（个人认为很少会遇到画图时axis label涉及多个物种）指定名字变成斜体。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
ggplot(SRS014459_Stool_profile, aes(x=V2)) + 
  geom_histogram(col=&amp;#39;black&amp;#39;) + theme_bw() + theme(axis.title = element_text(size=23)) +
  labs(x=formatPhrase(&amp;quot;Hello E. coli! Good-bye!&amp;quot;,&amp;quot;E. coli&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-r-metagenomeViz-italicTaxon_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microbiomeViz--人生第一个R包</title>
      <link>/post/2018-01-18-r-metagenomeviz/</link>
      <pubDate>Thu, 18 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-18-r-metagenomeviz/</guid>
      <description>&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;为啥写这个&lt;/h3&gt;
&lt;p&gt;平日经常会分析shotgun宏基因组的数据，我们的&lt;a href=&#34;https://github.com/gis-rpd/pipelines/tree/devel/metagenomics/shotgun-metagenomics&#34;&gt;pipeline&lt;/a&gt;使用MetaPhlAn，Kraken等profiler。这种数据经常会产生一个表格，如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;download.file(&amp;quot;https://bitbucket.org/biobakery/biobakery/raw/tip/demos/biobakery_demos/data/metaphlan2/output/SRS014459-Stool_profile.txt&amp;quot;, &amp;#39;~/Downloads/SRS014459-Stool_profile.txt&amp;#39;)
knitr::kable(head(read.table(&amp;#39;~/Downloads/SRS014459-Stool_profile.txt&amp;#39;)))&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;V1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;V2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;100.00000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Bacteroidetes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35.08247&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes|c__Clostridia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Bacteroidetes|c__Bacteroidia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35.08247&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes|c__Clostridia|o__Clostridiales&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第一列是分类信息注释，第二列是相对丰度（百分比）。在做这种图可视化方面，目前个人见过最强大的是&lt;a href=&#34;https://bitbucket.org/nsegata/graphlan/wiki/Home&#34;&gt;GraPhlAn&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://bytebucket.org/nsegata/graphlan/wiki/GraPhlAn_Fig1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;官网上相关的教程很详细，但是问题是，这个完全封闭的python程序，想要hack，还真的是挺难得。&lt;a href=&#34;https://github.com/marbl/Krona/wiki&#34;&gt;Krona&lt;/a&gt;可能是另一个选择，但是同样还是会有同样的问题。最近发布的R包&lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005404&#34;&gt;Metacoder&lt;/a&gt;，画出的图个人真心不是很喜欢：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;http://journals.plos.org/ploscompbiol/article/figure/image?size=large&amp;amp;id=info:doi/10.1371/journal.pcbi.1005404.g002&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;跟Y叔讨论了一下用ggtree实现像GraPhlAn那样图的可能性，得到了肯定的答复，于是开始自己造轮子。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;microbiomeviz&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;MicrobiomeViz–千里之行，始于足下&lt;/h3&gt;
&lt;p&gt;其实可以写一个简单的函数，但是还是想做一个拓展性更强的东西，所以就有了这个包（不断完善中）： &lt;a href=&#34;https://github.com/lch14forever/microbiomeViz&#34; class=&#34;uri&#34;&gt;https://github.com/lch14forever/microbiomeViz&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;metaphlanparser&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;MetaPhlan结果的parser&lt;/h3&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;安装&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;quot;lch14forever/microbiomeViz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in strptime(x, fmt, tz = &amp;quot;GMT&amp;quot;): unknown timezone &amp;#39;zone/tz/2017c.
## 1.0/zoneinfo/Asia/Singapore&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Skipping install of &amp;#39;microbiomeViz&amp;#39; from a github remote, the SHA1 (bff057bf) has not changed since last install.
##   Use `force = TRUE` to force installation&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;p&gt;目前有三个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parseMetaphlanTSV&lt;/code&gt;: 将MetaPhlAn的表格转换成tree格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tree.backbone&lt;/code&gt;: 做出树的骨架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clade.anno&lt;/code&gt;: 高亮一个节点及其下属所有节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个其实是基于之前做桑基图时写的那些代码，将MetaPhlan表格转化为了phylobase的phylo4d类：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;SRS014459_Stool_profile&amp;quot;)                    ## 上面的示例数据已经加如microbiomeViz
tr &amp;lt;- parseMetaphlanTSV(SRS014459_Stool_profile)   ## parsing&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ggtree&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;基于ggtree的大戏&lt;/h4&gt;
&lt;p&gt;做出树的骨架&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p &amp;lt;- tree.backbone(tr)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-18-r-metagenomeViz_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;微生物组常见的操作就是组间比较，我们可以向GraPhlAn那样把显著的节点高亮出来：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 假设以下taxa在疾病组显著
anno.data &amp;lt;- data.frame(node=c(&amp;quot;g__Roseburia&amp;quot;, &amp;quot;c__Clostridia&amp;quot;, &amp;quot;s__Bacteroides_ovatus&amp;quot;),
                       color=&amp;#39;red&amp;#39;, stringsAsFactors = FALSE)
p &amp;lt;- clade.anno(p, anno.data)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-18-r-metagenomeViz_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;希望有更多的拓展&lt;/h3&gt;
&lt;p&gt;所有的操作均基于&lt;code&gt;treedata&lt;/code&gt;和&lt;code&gt;ggtree&lt;/code&gt;，正因为有了这些灵活的框架，上面的几个例子可拓展性还是很强的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] 多个MetaPhlan表，节点大小取平均&lt;/li&gt;
&lt;li&gt;[ ] Biom数据支持&lt;/li&gt;
&lt;li&gt;[ ] 和heatmap结合&lt;/li&gt;
&lt;li&gt;[ ] …&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>成分之咒与ReBoot算法</title>
      <link>/post/2018-01-12-r-compositional/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-12-r-compositional/</guid>
      <description>&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;本文的大部分内容都来自我们之前的一篇综述文章&lt;a href=&#34;http://www.sciencedirect.com/science/article/pii/S1046202315300943?via%3Dihub&#34;&gt;Li et al, 2016&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;微生物组测序与成分数据&lt;/h1&gt;
&lt;p&gt;微生物组测序数据的获得其实有很多抽样过程（Sampling process）存在，比如说，粪便微生物组其实是对肠道微生物的一次抽样，测序的过程也是对所有DNA分子的一次抽样。最后，我们得到的OTU表中的OTU read count与测序深度相关，很显然测序深度是一个技术上的干扰因子（confounder），所以我们要对OTU表进行标准化（Normalization）。最简单的标准化方法，就是用read count除以样本内所有OTU的read count之和，获得每个OTU的相对丰度（relative abundance）。这种只有相对丰度的数据（相加总数为常数1或100）被称为成分数据（Compositional data）。 你可能注意到，作为成分数据一种的微生物组的数据中缺乏一个重要的信息–微生物总量（total abundance）。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;curse-of-compositionality&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;成分之咒（Curse of compositionality）&lt;/h1&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;（一些推导的废话可以跳过）&lt;/h3&gt;
&lt;p&gt;成分数据会对一些列统计分析产生影响，最典型的就是计算相关系数（correlation）。其中Pearson相关系数&lt;span class=&#34;math inline&#34;&gt;\(\rho_{X,Y}\)&lt;/span&gt;是由协方差矩阵算出来的，对于两个OTU的数量（由随机变量&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;表示），相关系数可以按下面公式计算（详细解释见&lt;a href=&#34;https://en.wikipedia.org/wiki/Pearson_correlation_coefficient&#34;&gt;维基百科&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[COV(X, Y)=E[(X-E[X])(Y-E[Y])]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\rho_{X,Y}=\frac{COV(X,Y)}{\sqrt{COV(X,X)\times COV(Y,Y)}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(COV(X,X)\)&lt;/span&gt;其实就是&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;的方差。其中根据协方差的性质我们可以得出成分数据的协方差性质：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sum_{i=1}^px_i=1 \Rightarrow \sum_{i=1,i\neq r}^pCOV(x_i, x_r)=-COV(x_r, x_r)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们知道方差（&lt;span class=&#34;math inline&#34;&gt;\(COV(x_r, x_r)\)&lt;/span&gt;）一定为正值，所以成分数据的协方差（同理相关系数）天然趋向于负值！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;天然的负相关&lt;/h3&gt;
&lt;p&gt;上面的公式推导，其实简单的想一想，因为相加为1，所以一个OTU相对丰度增加，其他OTU必然减少，所以本来不相关的OTU数量在转化为成分数据后也会有负相关的趋势，也就是我们常见的微生物组领域所说的Compositional effect或Compositional bias。以下为简单的一个实验，Species 1和Speacies 2本来不相关，但是其相对丰度负相关：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 加载r包
library(ggplot2)
library(reshape2)
library(cowplot)

## ggplot主题配置
figtheme &amp;lt;- theme_bw() + theme(text = element_text(size=10,face=&amp;#39;bold&amp;#39;),panel.border  = element_rect(colour = &amp;quot;black&amp;quot;,size=2))
theme_set(figtheme)

## 随机产生独立的5个OTU绝对数量 
means &amp;lt;- c(400,300,95,90,85)
data &amp;lt;- sapply(means, function(x) rnorm(100, x, x*0.05))
colnames(data) &amp;lt;- c(&amp;#39;Species1&amp;#39;, &amp;#39;Species2&amp;#39;,&amp;#39;Species3&amp;#39;,&amp;#39;Species4&amp;#39;,&amp;#39;Species5&amp;#39;)

## 绝对数量的画图
data.long &amp;lt;- melt(data)
colnames(data.long) &amp;lt;- c(&amp;#39;Sample&amp;#39;,&amp;#39;Species&amp;#39;,&amp;#39;Abundances&amp;#39;)
p1 &amp;lt;- ggplot(data.long, aes(x=Sample, y=Abundances, group=Species, color=Species)) + geom_line(size=1) + labs(y=&amp;#39;Absolute Abundance&amp;#39;)
p2 &amp;lt;- ggplot(data.frame(data), aes(x=Species1, y=Species2)) + geom_smooth(se=F,size=2,col=&amp;#39;cyan&amp;#39;) + geom_point(alpha = .7, size=2, col=&amp;#39;darkblue&amp;#39;)  + labs(title=&amp;#39;Absolute Abundances&amp;#39;,x=&amp;#39;Species 1&amp;#39;, y=&amp;#39;Species 2&amp;#39;)

## 相对丰度
data.norm &amp;lt;- t(apply(data, 1, function(x) x/sum(x)))
data.norm.long &amp;lt;- melt(data.norm)
colnames(data.norm.long) &amp;lt;- c(&amp;#39;Sample&amp;#39;,&amp;#39;Species&amp;#39;,&amp;#39;Abundances&amp;#39;)
p3 &amp;lt;- ggplot(data.frame(data.norm), aes(x=Species1, y=Species2)) + geom_smooth(se=F,size=2,col=&amp;#39;pink&amp;#39;) + geom_point(alpha = .7, size=2, col=&amp;#39;darkred&amp;#39;) + labs(title=&amp;#39;Relative Abundances&amp;#39;,x=&amp;#39;Species 1&amp;#39;, y=&amp;#39;Species 2&amp;#39;)

plot_grid(p1,plot_grid(p2,p3, nrow=1), ncol=1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-12-r-compositional_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;成分之咒（Curse of compositionality）这个词出现于今年发表于Nature Biotechnology的一篇&lt;a href=&#34;https://www.nature.com/articles/nbt.3935&#34;&gt;综述文章&lt;/a&gt;，讲的就是成分数据对相关系数的影响。 我所阅读到最早在微生物组领域提出这个问题，并给出解决算法的两篇文章（&lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002606&#34;&gt;Faust et al&lt;/a&gt;, &lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002687&#34;&gt;Friedman et al&lt;/a&gt;）都来自2012年的PLOS Computational Biology。这两篇文章可能你没有读过，但是他们都演化成了很有名的工具，前者就是R包&lt;a href=&#34;http://bioconductor.org/packages/release/bioc/html/ccrepe.html&#34;&gt;CCREPE&lt;/a&gt;和Cytoscape插件&lt;a href=&#34;http://psbweb05.psb.ugent.be/conet/&#34;&gt;CoNet&lt;/a&gt;，后者就是&lt;a href=&#34;https://bitbucket.org/yonatanf/sparcc&#34;&gt;SparCC&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ccrepereboot&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;CCREPE的ReBoot算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：这里先介绍CCREPE算法，并不是因为它是最好的算法，只是因为它算法简单，同样用这个算法来演示下载、清洗、可视化数据。&lt;/p&gt;
&lt;p&gt;大佬Curtis Huttenhower的ReBoot想法很简单，对于一个OTU表，我们把每一个OTU在不同样本中的数量打乱，这样所有的OTU数量都独立而不应该相关，之后我们从新标准化到相对丰度，然后计算相关系数，所有的非0相关系数都是由于标准化导致的假阳性（False positive）。这样的过程可以重复N次，然后我们就得到了每一对OTU的相关系数的一个零分布（Null distribution）。然后我们用原始的数据计算出的相关系数跟这个零分布比较一下，就可以获得p值，显著的p值才是真正相关的（其中的bootstrap算法跟成分数据关系不大，所以在次略过）。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/reboot.png&#34; alt=&#34;ReBoot算法&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;ReBoot算法&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ccrepe&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;使用CCREPE计算相关系数&lt;/h3&gt;
&lt;p&gt;安装CCREPE：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;https://bioconductor.org/biocLite.R&amp;quot;)
biocLite(&amp;quot;ccrepe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载并解压HMP &lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/otu_table_psn_v35.txt.gz&#34;&gt;16S数据&lt;/a&gt;和&lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/v35_map_uniquebyPSN.txt.bz2&#34;&gt;元数据&lt;/a&gt;（以下认为保存于“~/Downloads/”），然后进行数据预处理：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 使用data.table包快速读取大数据
library(data.table)
library(tidyverse)
## 元数据
metadata &amp;lt;- fread(&amp;#39;~/Downloads/v35_map_uniquebyPSN.txt&amp;#39;)
## 选出唾液数据并去掉唾液中不存在的OTU
IDs &amp;lt;- c(&amp;#39;#OTU ID&amp;#39;, as.character((metadata %&amp;gt;% filter(HMPbodysubsite==&amp;#39;Saliva&amp;#39;))[,1]))
otutab &amp;lt;- data.frame(fread(&amp;#39;~/Downloads/otu_table_psn_v35.txt&amp;#39;,head=TRUE, select=IDs,sep=&amp;#39;\t&amp;#39;) %&amp;gt;% 
    filter(rowSums(.[,-1])&amp;gt;0), 
    row.names = 1
    )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Starting data input on line 2 and discarding line 1 because it has
## too few or too many items to be column names or data: # QIIME v1.3.0-dev
## OTU table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Column name &amp;#39;700038483&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Column name &amp;#39;700038903&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
Read 66.1% of 45383 rows
Read 45383 rows and 291 (of 4790) columns from 0.409 GB file in 00:00:04&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 筛选数据
otutab.fil &amp;lt;- otutab %&amp;gt;% select(which(colSums(otutab)&amp;gt; 3000 )) %&amp;gt;% ## 样本筛选：样本read总数超过2000
                     filter(rowSums(.&amp;gt;1) &amp;gt; NCOL(.)*0.8)## OTU筛选：超过1个read的样本数量在90%以上
## 得到30个OTU，215个样本

## 标准化成relative abundance
otutab.fil.norm &amp;lt;- apply(otutab.fil, 2, function(x)x/sum(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用CCREPE来计算Co-occurence网络，使用&lt;strong&gt;Spearman&lt;/strong&gt;相关系数：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ccrepe)
ccrepe.res &amp;lt;- ccrepe(x=t(otutab.fil.norm))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果有4部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p.value&lt;/code&gt;：ReBoot测试p值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z.stat&lt;/code&gt;：Z-score&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sim.score&lt;/code&gt;：计算出的相关系数，默认值为Spearman相关系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.value&lt;/code&gt;：FDR修正过的p值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们需要的是q.value和sim.score。&lt;/p&gt;
&lt;p&gt;可视化：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(igraph)

## 根据q值过滤Co-occurrence矩阵
mat &amp;lt;- ccrepe.res$sim.score
mat[ccrepe.res$q.values &amp;gt; 1e-5] &amp;lt;- 0 ## q值不小于1e-5的correlation设为0
## 导入igraph
g &amp;lt;- graph_from_adjacency_matrix(adjmatrix=mat, mode=c(&amp;#39;undirected&amp;#39;), weighted = TRUE, diag = FALSE)
## 去掉没有边的节点
g &amp;lt;- delete.vertices(g, V(g)[degree(g)==0])
## 根据correlation方向上色
E(g)$color &amp;lt;- ifelse(E(g)$weight&amp;gt;0, &amp;#39;green&amp;#39;, &amp;#39;red&amp;#39;)
## 根据correlation值设置边的粗细
E(g)$width &amp;lt;-  abs(E(g)$weight) * 5
plot(g, layout=layout_with_lgl(g), edge.curved=.3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-12-r-compositional_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;写在后面&lt;/h1&gt;
&lt;p&gt;画图完成了，剩下的就是进行生物学的解读了，比如算出这个网络有什么特征等等。但是自己想特别说一下，在上面的网络中，使用CCREPE的&lt;code&gt;sim.score&lt;/code&gt;的正负和绝对值其实不是很有意义，因为&lt;code&gt;sim.score&lt;/code&gt;其实就是Spearman相关系数，虽然我们删去了可能由于成分数据特征造成的假阳性，但是对于这些保留下来的相关系数如何处理，CCREPE其实并没有操作，所以在解读时一定要小心。另外记得之前看到一篇文章说（找不到了），很多人喜欢在微生物组的文章里画这么一个Co-occurence网络图，但是并没有进行解读，只是为了“See! We can do system biology!”。所以还是说，即使是数据导向的组学，“套路”的时候也要清楚知道自己做的是什么，为什么（不）可以这样做，回答了什么样的生物学问题。&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ggplot扩展学习笔记--逐行解析Y叔的&#34;geom_ord_ellipse.R&#34;</title>
      <link>/post/2018-01-09-r-ordellipsecode/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-09-r-ordellipsecode/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;看到Y叔为&lt;a href=&#34;https://github.com/fawda123/ggord&#34;&gt;ggord&lt;/a&gt;做的添加置信椭圆的&lt;a href=&#34;https://github.com/GuangchuangYu/yyplot/blob/master/R/geom_ord_ellipse.R&#34;&gt;geom_ord_ellipse.R&lt;/a&gt;（用法见&lt;a href=&#34;http://lchblogs.netlify.com/post/2017-12-29-r-addconfellipse/&#34;&gt;上一篇文章&lt;/a&gt;），决定学习一点ggplot图形的语言，对于初学者最好的方法就是照葫芦画瓢，而Y叔的代码自然是最好的模板。我对Y叔的代码进行了逐行的分析，希望以后有需要可以套用。&lt;/p&gt;
&lt;p&gt;以下为&lt;code&gt;geom_ord_ellipse.R&lt;/code&gt;代码。这个图层的代码其实很短，很简洁，但是如果想要透彻理解还是需要下些功夫的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;##&amp;#39; add confidence ellipse to ordinary plot produced by ggord
##&amp;#39;
##&amp;#39; 
##&amp;#39; @title geom_ord_ellipse 
##&amp;#39; @param mapping aes mapping 
##&amp;#39; @param ellipse_pro confidence value for the ellipse
##&amp;#39; @param fill color to fill the ellipse, NA by default
##&amp;#39; @param ... additional parameters
##&amp;#39; @return ggplot layer
##&amp;#39; @importFrom ggplot2 aes_
##&amp;#39; @importFrom ggplot2 layer
##&amp;#39; @importFrom utils modifyList
##&amp;#39; @export
##&amp;#39; @author Guangchuang Yu
##&amp;#39; @references \url{http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/}
geom_ord_ellipse &amp;lt;- function(mapping = NULL, ellipse_pro = 0.97, fill = NA, ...) {
    default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)
    if (is.null(mapping)) {
        mapping &amp;lt;- default_aes
    } else {
        mapping &amp;lt;- modifyList(default_aes, mapping)
    }
    
    layer(
        geom = &amp;quot;polygon&amp;quot;,
        stat = StatOrdEllipse,
        mapping = mapping,
        position = &amp;#39;identity&amp;#39;,
        data = NULL,
        params = list(
            ellipse_pro = ellipse_pro,
            fill = fill,
            ...
        )
    )
}

##&amp;#39; @importFrom ggplot2 ggproto
##&amp;#39; @importFrom ggplot2 Stat
##&amp;#39; @importFrom plyr ddply
##&amp;#39; @importFrom grDevices chull
StatOrdEllipse &amp;lt;- ggproto(&amp;quot;StatOrdEllipse&amp;quot;, Stat,
                          compute_group = function(self, data, scales, params, ellipse_pro) {
                              names(data)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
                              theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
                              circle &amp;lt;- cbind(cos(theta), sin(theta))
                              ell &amp;lt;- ddply(data, .(group), function(x) {
                                  if(nrow(x) &amp;lt;= 2) {
                                      return(NULL)
                                  }
                                  sigma &amp;lt;- var(cbind(x$one, x$two))
                                  mu &amp;lt;- c(mean(x$one), mean(x$two))
                                  ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
                                  data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
                              })
                              names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
                              ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])
                              names(ell) &amp;lt;- c(&amp;#39;Groups&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;)
                              return(ell)
                          },
                          required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;group&amp;quot;)
                          )


## . function was from plyr package
. &amp;lt;- function (..., .env = parent.frame()) {
    structure(as.list(match.call()[-1]), env = .env, class = &amp;quot;quoted&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;roxygen&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;roxygen&lt;/code&gt;文档注释&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;##&amp;#39; add confidence ellipse to ordinary plot produced by ggord
##&amp;#39;
##&amp;#39; 
##&amp;#39; @title geom_ord_ellipse 
##&amp;#39; @param mapping aes mapping 
...
##&amp;#39; @return ggplot layer
##&amp;#39; @importFrom ggplot2 aes_
...
##&amp;#39; @export
##&amp;#39; @author Guangchuang Yu
##&amp;#39; @references \url{http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;roxygen会根据这一部分对单一函数生成帮助文档，也就是我们在R命令行中输入&lt;code&gt;?FunctionName&lt;/code&gt;看到的帮助信息。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/roxygen.png&#34; alt=&#34;渲染后的帮助文档&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;渲染后的帮助文档&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其基础格式是（Y叔使用了&lt;code&gt;##&#39;&lt;/code&gt;，我觉得好像跟&lt;code&gt;#&#39;&lt;/code&gt;没有什么区别？）：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#&amp;#39; @param 函数参数（对应Arguments） 函数的介绍（对应Description）&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的注释大多可以顾名思义。比较有意思的是&lt;code&gt;#&#39; @export&lt;/code&gt;这行了，roxygen会把这个函数放在&lt;code&gt;NAMESPACE&lt;/code&gt;文件中，这样用户便可以调用这个函数。我是可以调用&lt;code&gt;yyplot::geom_ord_ellipse()&lt;/code&gt;这个函数的。但&lt;code&gt;yyplot:StatOrdEllipse()&lt;/code&gt;这个函数是yyplot的内部函数（注意代码中此函数没有&lt;code&gt;#&#39; @export&lt;/code&gt;注释）。如果我调用就会报错：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yyplot::StatOrdEllipse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: &amp;#39;StatOrdEllipse&amp;#39; is not an exported object from &amp;#39;namespace:yyplot&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多关于roxygen的介绍可以参考&lt;a href=&#34;http://kbroman.org/pkg_primer/pages/docs.html&#34;&gt;这篇文章&lt;/a&gt;或&lt;a href=&#34;https://github.com/klutometis/roxygen&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ggprotoggplot2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;ggproto&lt;/code&gt;–&lt;code&gt;ggplot2&lt;/code&gt;的语言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ggplot2.tidyverse.org/reference/ggproto.html&#34;&gt;ggproto&lt;/a&gt;是ggplot2模块化、面向对象（Object Oriented）化的核心部分。基础的格式是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggproto(`_class` = NULL, `_inherit` = NULL, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ggproto&lt;/code&gt;是一个很庞大的系统，我目前理解还不是很深入，提供一些参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rdocumentation.org/packages/ggplot2/versions/2.2.1/topics/ggplot2-ggproto&#34;&gt;官方详细文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html&#34;&gt;ggproto教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在理解Y叔这个脚本中我们需要使用最基础的两个模块&lt;code&gt;Geom&lt;/code&gt;（创建图层），&lt;code&gt;Stat&lt;/code&gt;（数据处理）。&lt;/p&gt;
&lt;div id=&#34;statordellipseggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;StatOrdEllipse&lt;/code&gt;内部函数–&lt;code&gt;ggplot2&lt;/code&gt;中的数据处理&lt;/h3&gt;
&lt;p&gt;我们在作图之前基本都是要对输入数据进行一些数据预处理，比如在做线箱图的时候需要计算中位数、IQR等。在这个脚本中，我们需要做的是计算置信区间椭圆，这一步是通过&lt;code&gt;ggplot::Stat&lt;/code&gt;实现的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;StatOrdEllipse &amp;lt;- ggproto(&amp;quot;StatOrdEllipse&amp;quot;, Stat,
                          compute_group = function(self, data, scales, params, ellipse_pro) {
                              ## 此处省略...
                              ## 解析见后文
                              return(ell)
                          },
                          required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;group&amp;quot;)
                          )&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_class&lt;/code&gt;：这个类的名字为&lt;code&gt;StatOrdEllipse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_inherit&lt;/code&gt;：继承&lt;code&gt;Stat&lt;/code&gt;类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_group&lt;/code&gt;：核心处理数据部分，对每一组进行处理，模板为&lt;code&gt;compute_group(self, data, scales, ...)&lt;/code&gt;，在这里，它主要接受置信区间（&lt;code&gt;ellipse_pro&lt;/code&gt;）参数，返回值为&lt;strong&gt;计算好的置信区间轮廓上的点坐标&lt;/strong&gt;。&lt;em&gt;另外，我认为这里&lt;code&gt;params&lt;/code&gt;并不必要&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;required_aes&lt;/code&gt;：创建图层所需要的mapping参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;geom_ord_ellipseggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;geom_ord_ellipse&lt;/code&gt;函数–创建&lt;code&gt;ggplot2&lt;/code&gt;图层&lt;/h3&gt;
&lt;p&gt;下面便是重头戏，使用上面的&lt;code&gt;Stat&lt;/code&gt;来创建一个&lt;code&gt;Geom&lt;/code&gt;图层。其实这就是一个普通的函数，只是为了返回一个图层&lt;code&gt;layer&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;geom_ord_ellipse &amp;lt;- function(mapping = NULL, ellipse_pro = 0.97, fill = NA, ...) {
    default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)
    if (is.null(mapping)) {
        mapping &amp;lt;- default_aes
    } else {
        mapping &amp;lt;- modifyList(default_aes, mapping)
    }
    layer(
        geom = &amp;quot;polygon&amp;quot;,
        stat = StatOrdEllipse,
        mapping = mapping,
        position = &amp;#39;identity&amp;#39;,
        data = NULL,
        params = list(
            ellipse_pro = ellipse_pro,
            fill = fill,
            ...
        )
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;函数的输入值：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt;：使用过ggplot2都不应该陌生，就是我们写的&lt;code&gt;aes(x=, y=)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ellipse_pro&lt;/code&gt;：置信区间的概率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt;：置信区间内部的颜色，&lt;code&gt;NA&lt;/code&gt;会产生透明的椭圆&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;输入预处理：&lt;/h4&gt;
&lt;p&gt;这里对输入的&lt;code&gt;mapping&lt;/code&gt;做了判断，如果没有输入，就会使用默认值，如果有输入，则替换默认值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)&lt;/code&gt;：定义了默认的aesthetics，使用&lt;code&gt;aes_&lt;/code&gt;时，变量要用双引号引用或使用&lt;code&gt;~&lt;/code&gt;（&lt;code&gt;~Groups&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modifyList&lt;/code&gt;：根据一个&lt;code&gt;list&lt;/code&gt;修改另一个&lt;code&gt;list&lt;/code&gt;中的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;ggplotlayer&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;返回的&lt;code&gt;ggplot::layer&lt;/code&gt;：&lt;/h4&gt;
&lt;p&gt;这个函数的模板是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;layer(geom = NULL, stat = NULL, data = NULL, mapping = NULL,
  position = NULL, params = list(), inherit.aes = TRUE,
  check.aes = TRUE, check.param = TRUE, subset = NULL, show.legend = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应到Y叔的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;geom = &amp;quot;polygon&amp;quot;&lt;/code&gt;：一个多边形（椭圆）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stat = StatOrdEllipse&lt;/code&gt;：使用我们定义的&lt;code&gt;Stat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapping = mapping&lt;/code&gt;：数据与图形的对应，如&lt;code&gt;x=, y=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position = &#39;identity&#39;&lt;/code&gt;：位置的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data = NULL&lt;/code&gt;：从上一图层继承&lt;/li&gt;
&lt;li&gt;&lt;code&gt;params = list(...)&lt;/code&gt;：&lt;code&gt;geom&lt;/code&gt;和&lt;code&gt;stat&lt;/code&gt;的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里，对于一些基本的图层，我觉得完全可以套用Y叔的这个模板。在宏基因组公众号中曾经有人问，这个&lt;code&gt;ggord&lt;/code&gt;包中能不能把那些向量去掉，或者加入少部分变量的向量，我想用这个模板完全可以实现，只需要用&lt;code&gt;GeomCurve&lt;/code&gt;来做个图层就可以了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;计算置信区间椭圆&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(data)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
circle &amp;lt;- cbind(cos(theta), sin(theta))
ell &amp;lt;- ddply(data, .(group), function(x) {
   if(nrow(x) &amp;lt;= 2) {
       return(NULL)
   }
   sigma &amp;lt;- var(cbind(x$one, x$two))
   mu &amp;lt;- c(mean(x$one), mean(x$two))
   ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
   data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
    })
names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])  
names(ell) &amp;lt;- c(&amp;#39;Groups&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个代码是从&lt;code&gt;ggord&lt;/code&gt;的源码改过来的。对于排序图来说，基本最后都会降维到一个低维的空间（2维），方便展示。所以，我们最后需要处理的问题就是根据2维上的散点，计算出这些点分布的可能范围（在2维正态分布的假设下，对协方差使用卡方检验）。其中涉及到我们要把数据分成组（不同椭圆，不同颜色标记），然后对每一组求出上述的范围。这个操作使用ddply实现的：&lt;/p&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;分而治之&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ell &amp;lt;- ddply(data, .(group), function(x) {
    ## ...
    ## 解析见后文
    })&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此，把&lt;code&gt;data&lt;/code&gt;根据&lt;code&gt;group&lt;/code&gt;拆分成组，然后每一组套用&lt;code&gt;function&lt;/code&gt;，最后再把结果组合（&lt;code&gt;rbind&lt;/code&gt;）在一起。以下我们介绍每一组是如何处理的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;计算置信椭圆&lt;/h4&gt;
&lt;p&gt;从统计上来讲这个置信椭圆是这样做的：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;做出一个单位圆（半径为单位1）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
## should be:
## theta &amp;lt;- seq(-pi, pi, length = 50)
circle &amp;lt;- cbind(cos(theta), sin(theta))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们知道单位圆的参数方程为&lt;span class=&#34;math inline&#34;&gt;\(x=\cos(\theta), y=\sin(\theta),\theta\in[0,2\pi]\)&lt;/span&gt;，在这里ggord的作者其实重复了两圈，具体的原因我也没有搞清楚，我认为&lt;em&gt;没有必要&lt;/em&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;套用公式把这个圆转换成椭圆&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sigma &amp;lt;- var(cbind(x$one, x$two))
mu &amp;lt;- c(mean(x$one), mean(x$two))
ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的转化实际是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X_{ell}=\boldsymbol\mu + k\boldsymbol X C(\boldsymbol\Sigma)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol\mu=(\bar x_1,\bar x_2)\)&lt;/span&gt;，也就是数据的中心，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;根据概率控制椭圆的大小（因为是针对2维正态分布的协方差，所以使用了卡方检验），&lt;span class=&#34;math inline&#34;&gt;\(C(\boldsymbol\Sigma)\)&lt;/span&gt;代表协方差矩阵的Cholesky分解，&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X_{ell}\)&lt;/span&gt;分别为圆和椭圆上对应点的坐标。&lt;/p&gt;
&lt;p&gt;至于为什么这么做，涉及一些线代推导，可以参见下面两篇文章（特别是第一篇）：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://jellymatter.wordpress.com/2011/03/31/drawing-confidence-ellipses-and-ellipsoids/#more-507&#34; class=&#34;uri&#34;&gt;https://jellymatter.wordpress.com/2011/03/31/drawing-confidence-ellipses-and-ellipsoids/#more-507&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/&#34; class=&#34;uri&#34;&gt;http://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;有点多余？&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分的意思是对之前算出的那些椭圆上的点找出对应的凸多边形。我认为对于上述方法得到的点已经在一个凸多边形上了（椭圆）。我没有太明白这一步的必要性，&lt;em&gt;去掉之后并没有发现影响&lt;/em&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Useful commands for Docker</title>
      <link>/post/2017-12-31-bioinfo-docker_notes/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-31-bioinfo-docker_notes/</guid>
      <description>&lt;section id=&#34;docker&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;改变Docker容器存储路径&lt;/h2&gt;
&lt;p&gt;Linux下Docker的默认存储目录为&lt;code&gt;/var/lib/docker&lt;/code&gt;。显然这个目录属于&lt;code&gt;root&lt;/code&gt;分区（如果安装时进行过分区的话）。而一般这个分区会较小，我们更希望把容器和镜像存储于&lt;code&gt;/home&lt;/code&gt;下。我根据这篇博客进行了更改&lt;a href=&#34;https://sanenthusiast.com/change-default-image-container-location-docker/&#34; class=&#34;uri&#34;&gt;https://sanenthusiast.com/change-default-image-container-location-docker/&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;docker&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Docker常用操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加载镜像：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;gunzip -c [docker.img.tar.gz] | docker load

docker pull [docker_image_name]

cat [docker_file] | docker build -t [image_name] -&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启动容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;# 基本命令
docker run -it [image_name] 
# 退出时删除容器，加载host的文件路径
docker run -it --rm -v /host/directory:/container/directory [image_name]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;attach&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker attach [container_name/container_hash_ID]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;detach（容器在后台运行）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ctrl+p Ctrl+q&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出所有容器（包括未在运行中的）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker ps -a 
docker rm [container] # 删除容器&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;列出所有镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker images
docker rmi [image] # 删除镜像&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;host和容器文件转移&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker cp [source] [target] # use container hash id or name &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Commit&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker commit [container_name/container_hash_ID] [image_ID/image_name:image_tag]&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Add confidence ellipse to LDA ordination plot II</title>
      <link>/post/2017-12-29-r-addconfellipse/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-29-r-addconfellipse/</guid>
      <description>&lt;section class=&#34;level2&#34;&gt;
&lt;h2&gt;为排序图添加置信范围曲线&lt;/h2&gt;
&lt;p&gt;上一篇&lt;a href=&#34;http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/&#34;&gt;文章&lt;/a&gt;我们利用&lt;a href=&#34;https://github.com/fawda123/ggord&#34;&gt;ggord&lt;/a&gt;的源代码改写了一个为LDA排序图添加置信曲线的函数，现在&lt;a href=&#34;https://guangchuangyu.github.io/&#34;&gt;Y叔&lt;/a&gt;已经把它改写成了一个geom添加在了他的&lt;a href=&#34;https://github.com/GuangchuangYu/yyplot&#34;&gt;yyplot&lt;/a&gt;包中。y叔扩展了它的功能，现在支持ggord中的其他排序图（我没有进行全面的测试）。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggord)
library(yyplot)
library(MASS)&lt;/code&gt;&lt;/pre&gt;
&lt;section id=&#34;lda&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;LDA&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- lda(Species ~ ., iris, prior = rep(1, 3)/3)
ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/lda-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;pca&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;PCA&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- prcomp(iris[, 1:4])
ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/pca-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;mds&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;MDS&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(vegan)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: permute&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: lattice&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## This is vegan 2.4-4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- metaMDS(iris[, 1:4])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Run 0 stress 0.03775523 
## Run 1 stress 0.05879963 
## Run 2 stress 0.05771902 
## Run 3 stress 0.03775576 
## ... Procrustes: rmse 6.70624e-05  max resid 0.0002355622 
## ... Similar to previous best
## Run 4 stress 0.0599531 
## Run 5 stress 0.04367524 
## Run 6 stress 0.05537389 
## Run 7 stress 0.03775524 
## ... Procrustes: rmse 9.47124e-06  max resid 4.820747e-05 
## ... Similar to previous best
## Run 8 stress 0.03775578 
## ... Procrustes: rmse 2.073778e-05  max resid 0.000125111 
## ... Similar to previous best
## Run 9 stress 0.04367554 
## Run 10 stress 0.03775534 
## ... Procrustes: rmse 1.898558e-05  max resid 5.211088e-05 
## ... Similar to previous best
## Run 11 stress 0.04367546 
## Run 12 stress 0.06174009 
## Run 13 stress 0.04367526 
## Run 14 stress 0.0377554 
## ... Procrustes: rmse 3.074059e-05  max resid 0.0001171343 
## ... Similar to previous best
## Run 15 stress 0.05093855 
## Run 16 stress 0.05398536 
## Run 17 stress 0.03775584 
## ... Procrustes: rmse 7.169048e-05  max resid 0.0002630254 
## ... Similar to previous best
## Run 18 stress 0.03775551 
## ... Procrustes: rmse 4.556503e-05  max resid 0.0001590274 
## ... Similar to previous best
## Run 19 stress 0.04804016 
## Run 20 stress 0.04355825 
## *** Solution reached&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/mds-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Add confidence ellipse to LDA ordination plot</title>
      <link>/post/2017-12-22-r-addconfellipselda/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-22-r-addconfellipselda/</guid>
      <description>&lt;section id=&#34;use-ggord-to-plot-lda-ordination-plot&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Use ggord to plot LDA ordination plot&lt;/h2&gt;
&lt;section id=&#34;installation&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;#39;fawda123/ggord&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;basic-lda-ordination-biplot&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Basic LDA ordination biplot&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(MASS)
ord &amp;lt;- lda(Species ~ ., iris, prior = rep(1, 3)/3)

library(ggord)
p &amp;lt;- ggord(ord, iris$Species)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-22-r-addConfEllipseLDA_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&#34;a-function-to-compute-confidence-ellipse&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;A function to compute confidence ellipse&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_lda_ell &amp;lt;- function(ord_in, grp_in, ellipse_pro = 0.97){
    ## adapted from https://github.com/fawda123/ggord/blob/master/R/ggord.R
    require(plyr)
    axes = c(&amp;#39;LD1&amp;#39;, &amp;#39;LD2&amp;#39;)
    obs &amp;lt;- data.frame(predict(ord_in)$x[, axes])
    obs$Groups &amp;lt;- grp_in
    names(obs)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
    theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
    circle &amp;lt;- cbind(cos(theta), sin(theta))
    ell &amp;lt;- ddply(obs, &amp;#39;Groups&amp;#39;, function(x) {
        if(nrow(x) &amp;lt;= 2) {
            return(NULL)
        }
        sigma &amp;lt;- var(cbind(x$one, x$two))
        mu &amp;lt;- c(mean(x$one), mean(x$two))
        ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
        data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
    })
    names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
    ell &amp;lt;- ddply(ell, .(Groups), function(x) x[chull(x$one, x$two), ])
    ell
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;using-the-function&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Using the function&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
anotherEll &amp;lt;- get_lda_ell(ord, iris$Species, 0.97)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: plyr&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + geom_polygon(data = anotherEll, 
                 aes_string(color = &amp;#39;Groups&amp;#39;, group = &amp;#39;Groups&amp;#39;),
                 lty=2, fill = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-22-r-addConfEllipseLDA_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
