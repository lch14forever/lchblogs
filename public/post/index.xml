<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chenhao&#39;s Personal Page</title>
    <link>/post/</link>
    <description>Recent content in Posts on Chenhao&#39;s Personal Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© This site was created with R BlogDown and HuGo by Chenhao Li.</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0800</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>启动Conda环境时自动更改环境变量</title>
      <link>/post/2019-08-17-conda-activate/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-17-conda-activate/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;这是一个神奇的路径&lt;/h2&gt;
&lt;p&gt;我们在服务器上用conda创建了一个叫&lt;code&gt;metagenomics&lt;/code&gt;的环境，希望将常用分析软件安装在该环境。其中一些软件需要使用新版本的gcc编译（如：kraken2）。安装的准备套路应该如下：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;export PATH=/opt/gcc-4.9.3/bin/:$PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64/:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如果我希望以上环境变量仅对我特定的Conda环境起效（&lt;code&gt;metagenomics&lt;/code&gt;）应该怎么办呢？我们需要像.bashrc (.bash_profile)和.bash_logout这样在环境activate和deactivate时自动执行的脚本。在Conda中，我们需要如下目录：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;ANACONDA_PATH/envs/ENV_PATH/etc/conda/
├── activate.d        
│   └── env_vars.sh   ## &amp;lt;- sourced when you do `conda activate`
└── deactivate.d     
    └── env_vars.sh   ## &amp;lt;- sourced when you do `conda deactivate`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下的就是shell脚本的编写了，在下面的例子中，我们创建了一个叫做metagenomics的环境，并在其中安装了metaphlan2，kraken2，strainphlan。&lt;/p&gt;
&lt;div id=&#34;activate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;activate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

## CANU
export OLD_PATH=$PATH
export PATH=$(echo $PATH | sed &amp;#39;s;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/utils/:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/strainphlan_src/:;&amp;#39;)
export R_LIBS=/mnt/software/unstowable/anaconda/envs/metagenomics/lib/R/library
export BOWTIE2_INDEXES=/mnt/genomeDB/misc/softwareDB/metaphlan/huttenhower.sph.harvard.edu/metaphlan/bowtie2db/

## Kraken2
export OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;deactivate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;deactivate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

export PATH=$OLD_PATH
export R_LIBS=
export BOWTIE2_INDEXES=
export LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在旧版的Anaconda中，&lt;code&gt;source deactivate&lt;/code&gt;默认会把&lt;code&gt;PATH&lt;/code&gt;变量中的第一个目录删掉，所以上面使用了&lt;code&gt;sed&lt;/code&gt;来把新目录插到第二个的位置。现在的conda版本(使用&lt;code&gt;conda deactivate&lt;/code&gt;)好像不存在这样的问题了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&#34; class=&#34;uri&#34;&gt;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Emacs远程连接R</title>
      <link>/post/2018-11-25-emacs-remote-r/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-11-25-emacs-remote-r/</guid>
      <description>&lt;section id=&#34;r&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;本地的R脚本，远程执行&lt;/h2&gt;
&lt;p&gt;从事生信工作，已经形成了对R语言的重度依赖，Rstudio作为专注于R的IDE拥有强大的优势，但是我还是更习惯于Emacs的ESS的操作。其实之前就遇到过一个挺有意思的问题，如何用本地的Emacs去编辑并执行服务器上的R脚本。一个很显而易见的方法就是用Emacs的Tramp SSH连接到服务器，打开R脚本，这个时候ESS会自动使用远程服务器的R来运行。但是问题来了，在画图的时候这个远程的R进程并不能通过X11把图传回，所以会自动存储为Rplot.pdf于工作目录。Google了很久，找到了以解决方案：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;打开本地shell/eshell (M-x shell/eshell)&lt;/li&gt;
&lt;li&gt;在打开的shell中连接远程服务器（ssh -X &lt;a href=&#34;mailto:user@remote.machine.ip&#34;&gt;user@remote.machine.ip&lt;/a&gt; 或 ssh -Y）并运行R&lt;/li&gt;
&lt;li&gt;使用ESS remote（M-x ess-remote）&lt;/li&gt;
&lt;li&gt;打开本地或远程（Tramp mode）的R脚本&lt;/li&gt;
&lt;li&gt;使用C-c C-n（在CUA mode关闭情况下可使用C-Enter）或C-c C-c逐行或区域执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述过程中，顺序其实不是很重要，唯一需要注意的是如果R脚本在服务器上，一定要先开启一个本地的shell，要不然Emacs会默认使用远程机器的shell。&lt;/p&gt;
&lt;p&gt;为了简化此过程，我写了一个函数并把它定义给快捷键C-c C-r（写在init.el或.emacs文件中）：&lt;/p&gt;
&lt;pre class=&#34;lisp&#34;&gt;&lt;code&gt;(defun spawn-ess-remote (login)
  &amp;quot;connect to remote server and open ssh&amp;quot;
  (interactive &amp;quot;sUser login (uname@server.ip): &amp;quot;)
  (pop-to-buffer (get-buffer-create (generate-new-buffer-name &amp;quot;Remote-R&amp;quot;)))
  (shell (current-buffer))
  (process-send-string nil (format&amp;quot;ssh -Y %s \n&amp;quot; login) )
  (process-send-string nil &amp;quot;R\n&amp;quot;)
  (ess-remote nil &amp;quot;R&amp;quot;))
(global-set-key (kbd &amp;quot;C-c C-r&amp;quot;) &amp;#39;spawn-ess-remote)
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Frequently Googled Questions</title>
      <link>/post/2018-09-05-bioinfo-cheatsheet/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-09-05-bioinfo-cheatsheet/</guid>
      <description>&lt;div id=&#34;linux&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Linux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Extract (decompress) with a file pattern (wildcard) &lt;a href=&#34;https://superuser.com/questions/504798/extract-specific-files-in-a-tar-archive-using-a-wildcard&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;tar -xf MyTar.tar --wildcards &amp;quot;*.jpg&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;ggplot2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rotate axis label &lt;a href=&#34;https://stackoverflow.com/questions/1330989/rotating-and-spacing-axis-labels-in-ggplot2&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;remove legend title &lt;a href=&#34;http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/#hiding-the-legend-title&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Remove title for fill legend
p + 
  guides(fill=guide_legend(title=NULL))

# Remove title for all legends
p + 
  theme(legend.title=element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;legends in multiple columns/rows &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/guide_legend.html&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A lot of interesting and useful things in this ref&lt;/li&gt;
&lt;li&gt;overriding the alpha value&lt;/li&gt;
&lt;li&gt;customizing the legend text angle&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  guides(col = guide_legend(nrow = 8))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>一（三）文你读不懂PCA和PCoA</title>
      <link>/post/2018-04-39-r-pca_pcoa/</link>
      <pubDate>Mon, 30 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-04-39-r-pca_pcoa/</guid>
      <description>&lt;div id=&#34;pcapcoa&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;三文读懂PCA和PCoA？&lt;/h2&gt;
&lt;p&gt;今天看到金唯智公众号的推文《三文读懂PCA和PCoA》（《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9e.html&#34;&gt;一&lt;/a&gt;》,《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9f.html&#34;&gt;二&lt;/a&gt;》,《&lt;a href=&#34;http://blog.sina.com.cn/s/blog_a0d2a3c00102xl9h.html&#34;&gt;三&lt;/a&gt;》)。作者以平民化的语言，剔除数学术语，介绍了二者的区别，是很好的尝试，但是文中提出的很多关键性总结，都存在着明显的漏洞。&lt;/p&gt;
&lt;p&gt;特别指出在第二篇文章中：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;PCA基于物种丰度矩阵就意味着PCA分析的矩阵维度是就等于物种数目&lt;/strong&gt;。换句话说，你要分析的样本如果要做PCA分析，那么一般来说有多少个物种就有多少个维度”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然说到丰度，那有一个很容易忽视的点，就是所有物种丰度相加为常数（1或100%），所以说数据的维数其实是物种数-1。而相对丰度其实并不在传统意义的欧式空间中（参见Aitchison的《The Statistical Analysis of Compositional Data》）。PCA涉及到的变换其实是会保持数据点之间欧式距离不变（考虑所有PC的话），那么PCA分析是否适用于丰度（成分）数据，是一个存在争议的课题（参见Aitchison的《Principal Component Analysis of Compositional Data》）。所以在成分数据（测序数据，特别是microbiome）数据的时候，我们常采用一些生态距离，然后做PCoA。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“同样的道理，&lt;strong&gt;PCoA基于样本间的距离矩阵就意味着PCoA分析的矩阵维度与样本数目相关&lt;/strong&gt;。如果你要分析的样本做PCoA分析的话，那么一般来说有n个样本就至多有n-1个维度”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个n（样本数目）和p（维度）的问题，维度就是维度，p就是p，不能混淆。&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;多数情况下，我们在做降维处理的时候，期望维数越低越好，这样我们就可以最大程度地保真原始数据&lt;/strong&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;天下没有免费的午餐，维数越低，保真度自然越低。而PCA、PCoA所做的是在低维空间中尽量多的保存数据之间的差异。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;“&lt;strong&gt;如果样本数目比较多，而物种数目比较少，那肯定首选PCA；如果样本数目比较少，而物种数目比较多，那肯定首选PCoA&lt;/strong&gt;”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个很有意思的问题，其实PCoA和PCA的结果取决于PCoA的实现，但是直觉上想，既然PCA的变换会保存数据点间的欧氏距离，那么它和基于欧式距离的PCoA有什么区别呢？&lt;/p&gt;
&lt;p&gt;下面做一个实验，我们用两组数据（样本数目&amp;gt;维度，纬度&amp;gt;样本数目）来看看R中常见的PCA和PCoA实现的结果有何不同。&lt;/p&gt;
&lt;div id=&#34;iris&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;iris：样本数目&amp;gt;维度&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Low dimensional data (n&amp;gt;&amp;gt;p)
data(iris)
par(mfrow=c(2,2),cex=0.7, pch=19)
## PCA
pca &amp;lt;- prcomp(iris[,-5])
plot(pca$x[,1:2], col=iris[,5], xlab=&amp;#39;PC1&amp;#39;,ylab=&amp;#39;PC2&amp;#39;, main=&amp;#39;PCA&amp;#39;)
## PCoA
pcoa &amp;lt;- cmdscale(dist(iris[,-5], method = &amp;quot;euclidean&amp;quot;))
plot(pcoa, xlab=&amp;#39;MDS1&amp;#39;,ylab=&amp;#39;MDS2&amp;#39;, col=iris[,5], main=&amp;#39;PCoA&amp;#39;)
## pairwise distances
plot(as.vector(dist(pca$x[,1:2])), as.vector(dist(pcoa)), 
     xlab=&amp;#39;PCA&amp;#39;, ylab=&amp;#39;PCoA&amp;#39;, main=&amp;#39;Pairwise distances&amp;#39;,
     pch=19, col=rgb(0,0,0,0.3), cex=0.5)
plot(as.vector(dist(pca$x[,1:2])) - as.vector(dist(pcoa)),
     main=&amp;#39;Difference in pairwise distances&amp;#39;, ylab=&amp;#39;Delta&amp;#39;,
     cex=0.5, col=rgb(0,0,0,0.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-39-r-pca_pcoa_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;gene-expression-dataset&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Gene expression dataset：维度&amp;gt;样本数目&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## High dimensional data (p&amp;gt;&amp;gt;n)
## source(&amp;quot;http://bioconductor.org/biocLite.R&amp;quot;)
## biocLite(&amp;quot;hopach&amp;quot;)
suppressMessages(library(hopach))
par(mfrow=c(2,2),cex=0.7, pch=19)
data(golub)
pca &amp;lt;- prcomp(t(golub))
plot(pca$x[,1:2], col=golub.cl+1, xlab=&amp;#39;PC1&amp;#39;,ylab=&amp;#39;PC2&amp;#39;, main=&amp;#39;PCA&amp;#39;)
pcoa &amp;lt;- cmdscale(dist(t(golub), method = &amp;quot;euclidean&amp;quot;))
plot(pcoa, xlab=&amp;#39;MDS1&amp;#39;,ylab=&amp;#39;MDS2&amp;#39;, col=golub.cl+1, main=&amp;#39;PCoA&amp;#39;)
plot(as.vector(dist(pca$x[,1:2])), as.vector(dist(pcoa)), 
     xlab=&amp;#39;PCA&amp;#39;, ylab=&amp;#39;PCoA&amp;#39;, main=&amp;#39;Pairwise distances&amp;#39;,
     pch=19, col=rgb(0,0,0,0.3), cex=0.5)
plot(as.vector(dist(pca$x[,1:2])) - as.vector(dist(pcoa)),
     main=&amp;#39;Difference in pairwise distances&amp;#39;, ylab=&amp;#39;Delta&amp;#39;,
     cex=0.5, col=rgb(0,0,0,0.3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-39-r-pca_pcoa_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;很明显，在基于欧氏距离的&lt;code&gt;cmdscale&lt;/code&gt;和PCA在前两个维度上并没有什么区别。我个人一度以为PCA和基于欧式距离的PCoA其实是等同的，但是后来我们在一些PCoA的实现中确实看到了和PCA结果的差异，但是其实这个差异并不是很大。网上其实有很多的讨论，比如&lt;a href=&#34;https://stats.stackexchange.com/questions/14002/whats-the-difference-between-principal-component-analysis-and-multidimensional&#34;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Generating GraPhlAn-like microbiome visualization using ggtree and microbiomeViz</title>
      <link>/post/2018-04-20-r-microbiomeviz_example/</link>
      <pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-04-20-r-microbiomeviz_example/</guid>
      <description>&lt;section id=&#34;data-downloading-and-preprocessing&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Data downloading and preprocessing&lt;/h3&gt;
&lt;p&gt;Now let’s try to generate a figure like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://bitbucket.org/nsegata/metaphlan/wiki/lefse_biomarkers_cladogram.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sample processed by MetaPhlAn:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/nsegata/metaphlan/wiki/profiled_samples.tar.bz2&#34; class=&#34;uri&#34;&gt;https://bitbucket.org/nsegata/metaphlan/wiki/profiled_samples.tar.bz2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Script to merge samples:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/nsegata/metaphlan/raw/2f1b17a1f4e9775fe1ce42c8481279a5e69f291f/utils/merge_metaphlan_tables.py&#34; class=&#34;uri&#34;&gt;https://bitbucket.org/nsegata/metaphlan/raw/2f1b17a1f4e9775fe1ce42c8481279a5e69f291f/utils/merge_metaphlan_tables.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Merge files into a single table&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;python merge_metaphlan_tables.py profiled_samples/*.txt &amp;gt; profiled_samples/merged_abundance_table.txt&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;now-switch-to-r&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Now switch to R&lt;/h3&gt;
&lt;section id=&#34;load-data-and-library&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Load data and library&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- read.table(&amp;quot;~/Downloads/profiled_samples/merged_abundance_table.txt&amp;quot;, head=TRUE, stringsAsFactors = FALSE)
df &amp;lt;- df[,-ncol(df)]
## Use row means as a proxy for node size
dat &amp;lt;- data.frame(V1=df[,1], V2=rowMeans(df[,-1]), stringsAsFactors = FALSE)

library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;parse-data-and-create-a-backbone&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Parse data and create a backbone&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tr &amp;lt;- parseMetaphlanTSV(dat, node.size.offset=2, node.size.scale=0.8)
p &amp;lt;- tree.backbone(tr, size=0.5)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-20-r-microbiomeviz_example_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;hard-coded-lefse-results&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Hard-coded lefse results&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lefse_lists = data.frame(node=c(&amp;#39;s__Haemophilus_parainfluenzae&amp;#39;,&amp;#39;p__Proteobacteria&amp;#39;,
                              &amp;#39;f__Veillonellaceae&amp;#39;,&amp;#39;o__Selenomonadales&amp;#39;,
                              &amp;#39;c__Negativicutes&amp;#39;, &amp;#39;s__Streptococcus_parasanguinis&amp;#39;,

                              &amp;#39;p__Firmicutes&amp;#39;,&amp;#39;f__Streptococcaceae&amp;#39;,
                              &amp;#39;g__Streptococcus&amp;#39;,&amp;#39;o__Lactobacillales&amp;#39;,
                              &amp;#39;c__Bacilli&amp;#39;,&amp;#39;s__Streptococcus_mitis&amp;#39;),
                         color=c(rep(&amp;#39;darkgreen&amp;#39;,6), rep(&amp;#39;red&amp;#39;,&amp;#39;6&amp;#39;)),
                         stringsAsFactors = FALSE
                         )&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;annotate-the-tree&#34; class=&#34;level4&#34;&gt;
&lt;h4&gt;Annotate the tree&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p &amp;lt;- clade.anno(p, lefse_lists, alpha=0.3)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-04-20-r-microbiomeviz_example_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Y叔的新包base2grob</title>
      <link>/post/2018-03-29-r-base2grob_igraph/</link>
      <pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-03-29-r-base2grob_igraph/</guid>
      <description>&lt;p&gt;测试了一下Y叔的新包&lt;a href=&#34;https://cran.r-project.org/web/packages/base2grob/vignettes/base2grob.html&#34;&gt;base2grob&lt;/a&gt;。这个包提供了base2grob函数，可以把base plot转换成grob对象。对于我来说最大的方便就是可以把一些igraph画出的网络图通过cowplot和其他ggplot做出的图自由组合。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(base2grob)
library(igraph)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;igraph&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:stats&amp;#39;:
## 
##     decompose, spectrum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:base&amp;#39;:
## 
##     union&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(cowplot)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: ggplot2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;cowplot&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:ggplot2&amp;#39;:
## 
##     ggsave&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g1 &amp;lt;- erdos.renyi.game(10, 0.2)
g2 &amp;lt;- erdos.renyi.game(10, 0.5)

E(g1)$width &amp;lt;- E(g2)$width &amp;lt;- 5
E(g1)$label.cex &amp;lt;- E(g2)$label.cex &amp;lt;- 1e-16 ## 这个我承认有点傻，但是没有找到更好的方法
V(g1)$color &amp;lt;- &amp;#39;cyan&amp;#39;
V(g2)$color &amp;lt;- &amp;#39;green&amp;#39;

p1 &amp;lt;- base2grob(~plot(g1))
p2 &amp;lt;- base2grob(~plot(g2))

plot_grid(p1, p2, labels=LETTERS[1:2])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-03-29-r-base2grob_igraph_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microbiomeViz--斜体显示taxon name</title>
      <link>/post/2018-02-01-r-metagenomeviz-italictaxon/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-02-01-r-metagenomeviz-italictaxon/</guid>
      <description>&lt;p&gt;微生物种名属名经常需要&lt;em&gt;&lt;code&gt;斜体&lt;/code&gt;&lt;/em&gt;表示，现在microbiomeViz添加了一个生成&lt;code&gt;expression&lt;/code&gt;的函数，可以直接将一个短语中的&lt;strong&gt;一个&lt;/strong&gt;（个人认为很少会遇到画图时axis label涉及多个物种）指定名字变成斜体。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
ggplot(SRS014459_Stool_profile, aes(x=V2)) + 
  geom_histogram(col=&amp;#39;black&amp;#39;) + theme_bw() + theme(axis.title = element_text(size=23)) +
  labs(x=formatPhrase(&amp;quot;Hello E. coli! Good-bye!&amp;quot;,&amp;quot;E. coli&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-02-01-r-metagenomeViz-italicTaxon_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>microbiomeViz--人生第一个R包</title>
      <link>/post/2018-01-18-r-metagenomeviz/</link>
      <pubDate>Thu, 18 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-18-r-metagenomeviz/</guid>
      <description>&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;为啥写这个&lt;/h3&gt;
&lt;p&gt;平日经常会分析shotgun宏基因组的数据，我们的&lt;a href=&#34;https://github.com/gis-rpd/pipelines/tree/devel/metagenomics/shotgun-metagenomics&#34;&gt;pipeline&lt;/a&gt;使用MetaPhlAn，Kraken等profiler。这种数据经常会产生一个表格，如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;download.file(&amp;quot;https://bitbucket.org/biobakery/biobakery/raw/tip/demos/biobakery_demos/data/metaphlan2/output/SRS014459-Stool_profile.txt&amp;quot;, &amp;#39;~/Downloads/SRS014459-Stool_profile.txt&amp;#39;)
knitr::kable(head(read.table(&amp;#39;~/Downloads/SRS014459-Stool_profile.txt&amp;#39;)))&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;V1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;V2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;100.00000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Bacteroidetes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35.08247&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes|c__Clostridia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Bacteroidetes|c__Bacteroidia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35.08247&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;k__Bacteria|p__Firmicutes|c__Clostridia|o__Clostridiales&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;64.91753&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;第一列是分类信息注释，第二列是相对丰度（百分比）。在做这种图可视化方面，目前个人见过最强大的是&lt;a href=&#34;https://bitbucket.org/nsegata/graphlan/wiki/Home&#34;&gt;GraPhlAn&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://bytebucket.org/nsegata/graphlan/wiki/GraPhlAn_Fig1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;官网上相关的教程很详细，但是问题是，这个完全封闭的python程序，想要hack，还真的是挺难得。&lt;a href=&#34;https://github.com/marbl/Krona/wiki&#34;&gt;Krona&lt;/a&gt;可能是另一个选择，但是同样还是会有同样的问题。最近发布的R包&lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005404&#34;&gt;Metacoder&lt;/a&gt;，画出的图个人真心不是很喜欢：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;http://journals.plos.org/ploscompbiol/article/figure/image?size=large&amp;amp;id=info:doi/10.1371/journal.pcbi.1005404.g002&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;跟Y叔讨论了一下用ggtree实现像GraPhlAn那样图的可能性，得到了肯定的答复，于是开始自己造轮子。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;microbiomeviz&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;MicrobiomeViz–千里之行，始于足下&lt;/h3&gt;
&lt;p&gt;其实可以写一个简单的函数，但是还是想做一个拓展性更强的东西，所以就有了这个包（不断完善中）： &lt;a href=&#34;https://github.com/lch14forever/microbiomeViz&#34; class=&#34;uri&#34;&gt;https://github.com/lch14forever/microbiomeViz&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;metaphlanparser&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;MetaPhlan结果的parser&lt;/h3&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;安装&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;quot;lch14forever/microbiomeViz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in strptime(x, fmt, tz = &amp;quot;GMT&amp;quot;): unknown timezone &amp;#39;zone/tz/2017c.
## 1.0/zoneinfo/Asia/Singapore&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Skipping install of &amp;#39;microbiomeViz&amp;#39; from a github remote, the SHA1 (bff057bf) has not changed since last install.
##   Use `force = TRUE` to force installation&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;p&gt;目前有三个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parseMetaphlanTSV&lt;/code&gt;: 将MetaPhlAn的表格转换成tree格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tree.backbone&lt;/code&gt;: 做出树的骨架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clade.anno&lt;/code&gt;: 高亮一个节点及其下属所有节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个其实是基于之前做桑基图时写的那些代码，将MetaPhlan表格转化为了phylobase的phylo4d类：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbiomeViz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: replacing previous import &amp;#39;ape::rotate&amp;#39; by &amp;#39;ggtree::rotate&amp;#39; when
## loading &amp;#39;microbiomeViz&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;SRS014459_Stool_profile&amp;quot;)                    ## 上面的示例数据已经加如microbiomeViz
tr &amp;lt;- parseMetaphlanTSV(SRS014459_Stool_profile)   ## parsing&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ggtree&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;基于ggtree的大戏&lt;/h4&gt;
&lt;p&gt;做出树的骨架&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p &amp;lt;- tree.backbone(tr)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-18-r-metagenomeViz_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;微生物组常见的操作就是组间比较，我们可以向GraPhlAn那样把显著的节点高亮出来：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 假设以下taxa在疾病组显著
anno.data &amp;lt;- data.frame(node=c(&amp;quot;g__Roseburia&amp;quot;, &amp;quot;c__Clostridia&amp;quot;, &amp;quot;s__Bacteroides_ovatus&amp;quot;),
                       color=&amp;#39;red&amp;#39;, stringsAsFactors = FALSE)
p &amp;lt;- clade.anno(p, anno.data)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-18-r-metagenomeViz_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;希望有更多的拓展&lt;/h3&gt;
&lt;p&gt;所有的操作均基于&lt;code&gt;treedata&lt;/code&gt;和&lt;code&gt;ggtree&lt;/code&gt;，正因为有了这些灵活的框架，上面的几个例子可拓展性还是很强的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] 多个MetaPhlan表，节点大小取平均&lt;/li&gt;
&lt;li&gt;[ ] Biom数据支持&lt;/li&gt;
&lt;li&gt;[ ] 和heatmap结合&lt;/li&gt;
&lt;li&gt;[ ] …&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>成分之咒与ReBoot算法</title>
      <link>/post/2018-01-12-r-compositional/</link>
      <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-12-r-compositional/</guid>
      <description>&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;本文的大部分内容都来自我们之前的一篇综述文章&lt;a href=&#34;http://www.sciencedirect.com/science/article/pii/S1046202315300943?via%3Dihub&#34;&gt;Li et al, 2016&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;微生物组测序与成分数据&lt;/h1&gt;
&lt;p&gt;微生物组测序数据的获得其实有很多抽样过程（Sampling process）存在，比如说，粪便微生物组其实是对肠道微生物的一次抽样，测序的过程也是对所有DNA分子的一次抽样。最后，我们得到的OTU表中的OTU read count与测序深度相关，很显然测序深度是一个技术上的干扰因子（confounder），所以我们要对OTU表进行标准化（Normalization）。最简单的标准化方法，就是用read count除以样本内所有OTU的read count之和，获得每个OTU的相对丰度（relative abundance）。这种只有相对丰度的数据（相加总数为常数1或100）被称为成分数据（Compositional data）。 你可能注意到，作为成分数据一种的微生物组的数据中缺乏一个重要的信息–微生物总量（total abundance）。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;curse-of-compositionality&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;成分之咒（Curse of compositionality）&lt;/h1&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;（一些推导的废话可以跳过）&lt;/h3&gt;
&lt;p&gt;成分数据会对一些列统计分析产生影响，最典型的就是计算相关系数（correlation）。其中Pearson相关系数&lt;span class=&#34;math inline&#34;&gt;\(\rho_{X,Y}\)&lt;/span&gt;是由协方差矩阵算出来的，对于两个OTU的数量（由随机变量&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;表示），相关系数可以按下面公式计算（详细解释见&lt;a href=&#34;https://en.wikipedia.org/wiki/Pearson_correlation_coefficient&#34;&gt;维基百科&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[COV(X, Y)=E[(X-E[X])(Y-E[Y])]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\rho_{X,Y}=\frac{COV(X,Y)}{\sqrt{COV(X,X)\times COV(Y,Y)}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(COV(X,X)\)&lt;/span&gt;其实就是&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;的方差。其中根据协方差的性质我们可以得出成分数据的协方差性质：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sum_{i=1}^px_i=1 \Rightarrow \sum_{i=1,i\neq r}^pCOV(x_i, x_r)=-COV(x_r, x_r)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们知道方差（&lt;span class=&#34;math inline&#34;&gt;\(COV(x_r, x_r)\)&lt;/span&gt;）一定为正值，所以成分数据的协方差（同理相关系数）天然趋向于负值！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;天然的负相关&lt;/h3&gt;
&lt;p&gt;上面的公式推导，其实简单的想一想，因为相加为1，所以一个OTU相对丰度增加，其他OTU必然减少，所以本来不相关的OTU数量在转化为成分数据后也会有负相关的趋势，也就是我们常见的微生物组领域所说的Compositional effect或Compositional bias。以下为简单的一个实验，Species 1和Speacies 2本来不相关，但是其相对丰度负相关：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 加载r包
library(ggplot2)
library(reshape2)
library(cowplot)

## ggplot主题配置
figtheme &amp;lt;- theme_bw() + theme(text = element_text(size=10,face=&amp;#39;bold&amp;#39;),panel.border  = element_rect(colour = &amp;quot;black&amp;quot;,size=2))
theme_set(figtheme)

## 随机产生独立的5个OTU绝对数量 
means &amp;lt;- c(400,300,95,90,85)
data &amp;lt;- sapply(means, function(x) rnorm(100, x, x*0.05))
colnames(data) &amp;lt;- c(&amp;#39;Species1&amp;#39;, &amp;#39;Species2&amp;#39;,&amp;#39;Species3&amp;#39;,&amp;#39;Species4&amp;#39;,&amp;#39;Species5&amp;#39;)

## 绝对数量的画图
data.long &amp;lt;- melt(data)
colnames(data.long) &amp;lt;- c(&amp;#39;Sample&amp;#39;,&amp;#39;Species&amp;#39;,&amp;#39;Abundances&amp;#39;)
p1 &amp;lt;- ggplot(data.long, aes(x=Sample, y=Abundances, group=Species, color=Species)) + geom_line(size=1) + labs(y=&amp;#39;Absolute Abundance&amp;#39;)
p2 &amp;lt;- ggplot(data.frame(data), aes(x=Species1, y=Species2)) + geom_smooth(se=F,size=2,col=&amp;#39;cyan&amp;#39;) + geom_point(alpha = .7, size=2, col=&amp;#39;darkblue&amp;#39;)  + labs(title=&amp;#39;Absolute Abundances&amp;#39;,x=&amp;#39;Species 1&amp;#39;, y=&amp;#39;Species 2&amp;#39;)

## 相对丰度
data.norm &amp;lt;- t(apply(data, 1, function(x) x/sum(x)))
data.norm.long &amp;lt;- melt(data.norm)
colnames(data.norm.long) &amp;lt;- c(&amp;#39;Sample&amp;#39;,&amp;#39;Species&amp;#39;,&amp;#39;Abundances&amp;#39;)
p3 &amp;lt;- ggplot(data.frame(data.norm), aes(x=Species1, y=Species2)) + geom_smooth(se=F,size=2,col=&amp;#39;pink&amp;#39;) + geom_point(alpha = .7, size=2, col=&amp;#39;darkred&amp;#39;) + labs(title=&amp;#39;Relative Abundances&amp;#39;,x=&amp;#39;Species 1&amp;#39;, y=&amp;#39;Species 2&amp;#39;)

plot_grid(p1,plot_grid(p2,p3, nrow=1), ncol=1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-12-r-compositional_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;成分之咒（Curse of compositionality）这个词出现于今年发表于Nature Biotechnology的一篇&lt;a href=&#34;https://www.nature.com/articles/nbt.3935&#34;&gt;综述文章&lt;/a&gt;，讲的就是成分数据对相关系数的影响。 我所阅读到最早在微生物组领域提出这个问题，并给出解决算法的两篇文章（&lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002606&#34;&gt;Faust et al&lt;/a&gt;, &lt;a href=&#34;http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002687&#34;&gt;Friedman et al&lt;/a&gt;）都来自2012年的PLOS Computational Biology。这两篇文章可能你没有读过，但是他们都演化成了很有名的工具，前者就是R包&lt;a href=&#34;http://bioconductor.org/packages/release/bioc/html/ccrepe.html&#34;&gt;CCREPE&lt;/a&gt;和Cytoscape插件&lt;a href=&#34;http://psbweb05.psb.ugent.be/conet/&#34;&gt;CoNet&lt;/a&gt;，后者就是&lt;a href=&#34;https://bitbucket.org/yonatanf/sparcc&#34;&gt;SparCC&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ccrepereboot&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;CCREPE的ReBoot算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：这里先介绍CCREPE算法，并不是因为它是最好的算法，只是因为它算法简单，同样用这个算法来演示下载、清洗、可视化数据。&lt;/p&gt;
&lt;p&gt;大佬Curtis Huttenhower的ReBoot想法很简单，对于一个OTU表，我们把每一个OTU在不同样本中的数量打乱，这样所有的OTU数量都独立而不应该相关，之后我们从新标准化到相对丰度，然后计算相关系数，所有的非0相关系数都是由于标准化导致的假阳性（False positive）。这样的过程可以重复N次，然后我们就得到了每一对OTU的相关系数的一个零分布（Null distribution）。然后我们用原始的数据计算出的相关系数跟这个零分布比较一下，就可以获得p值，显著的p值才是真正相关的（其中的bootstrap算法跟成分数据关系不大，所以在次略过）。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/reboot.png&#34; alt=&#34;ReBoot算法&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;ReBoot算法&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;ccrepe&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;使用CCREPE计算相关系数&lt;/h3&gt;
&lt;p&gt;安装CCREPE：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;https://bioconductor.org/biocLite.R&amp;quot;)
biocLite(&amp;quot;ccrepe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载并解压HMP &lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/otu_table_psn_v35.txt.gz&#34;&gt;16S数据&lt;/a&gt;和&lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/v35_map_uniquebyPSN.txt.bz2&#34;&gt;元数据&lt;/a&gt;（以下认为保存于“~/Downloads/”），然后进行数据预处理：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 使用data.table包快速读取大数据
library(data.table)
library(tidyverse)
## 元数据
metadata &amp;lt;- fread(&amp;#39;~/Downloads/v35_map_uniquebyPSN.txt&amp;#39;)
## 选出唾液数据并去掉唾液中不存在的OTU
IDs &amp;lt;- c(&amp;#39;#OTU ID&amp;#39;, as.character((metadata %&amp;gt;% filter(HMPbodysubsite==&amp;#39;Saliva&amp;#39;))[,1]))
otutab &amp;lt;- data.frame(fread(&amp;#39;~/Downloads/otu_table_psn_v35.txt&amp;#39;,head=TRUE, select=IDs,sep=&amp;#39;\t&amp;#39;) %&amp;gt;% 
    filter(rowSums(.[,-1])&amp;gt;0), 
    row.names = 1
    )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Starting data input on line 2 and discarding line 1 because it has
## too few or too many items to be column names or data: # QIIME v1.3.0-dev
## OTU table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Column name &amp;#39;700038483&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/Downloads/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select
## = IDs, : Column name &amp;#39;700038903&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
Read 66.1% of 45383 rows
Read 45383 rows and 291 (of 4790) columns from 0.409 GB file in 00:00:04&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## 筛选数据
otutab.fil &amp;lt;- otutab %&amp;gt;% select(which(colSums(otutab)&amp;gt; 3000 )) %&amp;gt;% ## 样本筛选：样本read总数超过2000
                     filter(rowSums(.&amp;gt;1) &amp;gt; NCOL(.)*0.8)## OTU筛选：超过1个read的样本数量在90%以上
## 得到30个OTU，215个样本

## 标准化成relative abundance
otutab.fil.norm &amp;lt;- apply(otutab.fil, 2, function(x)x/sum(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用CCREPE来计算Co-occurence网络，使用&lt;strong&gt;Spearman&lt;/strong&gt;相关系数：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ccrepe)
ccrepe.res &amp;lt;- ccrepe(x=t(otutab.fil.norm))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果有4部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;p.value&lt;/code&gt;：ReBoot测试p值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;z.stat&lt;/code&gt;：Z-score&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sim.score&lt;/code&gt;：计算出的相关系数，默认值为Spearman相关系数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.value&lt;/code&gt;：FDR修正过的p值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们需要的是q.value和sim.score。&lt;/p&gt;
&lt;p&gt;可视化：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(igraph)

## 根据q值过滤Co-occurrence矩阵
mat &amp;lt;- ccrepe.res$sim.score
mat[ccrepe.res$q.values &amp;gt; 1e-5] &amp;lt;- 0 ## q值不小于1e-5的correlation设为0
## 导入igraph
g &amp;lt;- graph_from_adjacency_matrix(adjmatrix=mat, mode=c(&amp;#39;undirected&amp;#39;), weighted = TRUE, diag = FALSE)
## 去掉没有边的节点
g &amp;lt;- delete.vertices(g, V(g)[degree(g)==0])
## 根据correlation方向上色
E(g)$color &amp;lt;- ifelse(E(g)$weight&amp;gt;0, &amp;#39;green&amp;#39;, &amp;#39;red&amp;#39;)
## 根据correlation值设置边的粗细
E(g)$width &amp;lt;-  abs(E(g)$weight) * 5
plot(g, layout=layout_with_lgl(g), edge.curved=.3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-01-12-r-compositional_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;写在后面&lt;/h1&gt;
&lt;p&gt;画图完成了，剩下的就是进行生物学的解读了，比如算出这个网络有什么特征等等。但是自己想特别说一下，在上面的网络中，使用CCREPE的&lt;code&gt;sim.score&lt;/code&gt;的正负和绝对值其实不是很有意义，因为&lt;code&gt;sim.score&lt;/code&gt;其实就是Spearman相关系数，虽然我们删去了可能由于成分数据特征造成的假阳性，但是对于这些保留下来的相关系数如何处理，CCREPE其实并没有操作，所以在解读时一定要小心。另外记得之前看到一篇文章说（找不到了），很多人喜欢在微生物组的文章里画这么一个Co-occurence网络图，但是并没有进行解读，只是为了“See! We can do system biology!”。所以还是说，即使是数据导向的组学，“套路”的时候也要清楚知道自己做的是什么，为什么（不）可以这样做，回答了什么样的生物学问题。&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ggplot扩展学习笔记--逐行解析Y叔的&#34;geom_ord_ellipse.R&#34;</title>
      <link>/post/2018-01-09-r-ordellipsecode/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-09-r-ordellipsecode/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;看到Y叔为&lt;a href=&#34;https://github.com/fawda123/ggord&#34;&gt;ggord&lt;/a&gt;做的添加置信椭圆的&lt;a href=&#34;https://github.com/GuangchuangYu/yyplot/blob/master/R/geom_ord_ellipse.R&#34;&gt;geom_ord_ellipse.R&lt;/a&gt;（用法见&lt;a href=&#34;http://lchblogs.netlify.com/post/2017-12-29-r-addconfellipse/&#34;&gt;上一篇文章&lt;/a&gt;），决定学习一点ggplot图形的语言，对于初学者最好的方法就是照葫芦画瓢，而Y叔的代码自然是最好的模板。我对Y叔的代码进行了逐行的分析，希望以后有需要可以套用。&lt;/p&gt;
&lt;p&gt;以下为&lt;code&gt;geom_ord_ellipse.R&lt;/code&gt;代码。这个图层的代码其实很短，很简洁，但是如果想要透彻理解还是需要下些功夫的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;##&amp;#39; add confidence ellipse to ordinary plot produced by ggord
##&amp;#39;
##&amp;#39; 
##&amp;#39; @title geom_ord_ellipse 
##&amp;#39; @param mapping aes mapping 
##&amp;#39; @param ellipse_pro confidence value for the ellipse
##&amp;#39; @param fill color to fill the ellipse, NA by default
##&amp;#39; @param ... additional parameters
##&amp;#39; @return ggplot layer
##&amp;#39; @importFrom ggplot2 aes_
##&amp;#39; @importFrom ggplot2 layer
##&amp;#39; @importFrom utils modifyList
##&amp;#39; @export
##&amp;#39; @author Guangchuang Yu
##&amp;#39; @references \url{http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/}
geom_ord_ellipse &amp;lt;- function(mapping = NULL, ellipse_pro = 0.97, fill = NA, ...) {
    default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)
    if (is.null(mapping)) {
        mapping &amp;lt;- default_aes
    } else {
        mapping &amp;lt;- modifyList(default_aes, mapping)
    }
    
    layer(
        geom = &amp;quot;polygon&amp;quot;,
        stat = StatOrdEllipse,
        mapping = mapping,
        position = &amp;#39;identity&amp;#39;,
        data = NULL,
        params = list(
            ellipse_pro = ellipse_pro,
            fill = fill,
            ...
        )
    )
}

##&amp;#39; @importFrom ggplot2 ggproto
##&amp;#39; @importFrom ggplot2 Stat
##&amp;#39; @importFrom plyr ddply
##&amp;#39; @importFrom grDevices chull
StatOrdEllipse &amp;lt;- ggproto(&amp;quot;StatOrdEllipse&amp;quot;, Stat,
                          compute_group = function(self, data, scales, params, ellipse_pro) {
                              names(data)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
                              theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
                              circle &amp;lt;- cbind(cos(theta), sin(theta))
                              ell &amp;lt;- ddply(data, .(group), function(x) {
                                  if(nrow(x) &amp;lt;= 2) {
                                      return(NULL)
                                  }
                                  sigma &amp;lt;- var(cbind(x$one, x$two))
                                  mu &amp;lt;- c(mean(x$one), mean(x$two))
                                  ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
                                  data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
                              })
                              names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
                              ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])
                              names(ell) &amp;lt;- c(&amp;#39;Groups&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;)
                              return(ell)
                          },
                          required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;group&amp;quot;)
                          )


## . function was from plyr package
. &amp;lt;- function (..., .env = parent.frame()) {
    structure(as.list(match.call()[-1]), env = .env, class = &amp;quot;quoted&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;roxygen&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;roxygen&lt;/code&gt;文档注释&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;##&amp;#39; add confidence ellipse to ordinary plot produced by ggord
##&amp;#39;
##&amp;#39; 
##&amp;#39; @title geom_ord_ellipse 
##&amp;#39; @param mapping aes mapping 
...
##&amp;#39; @return ggplot layer
##&amp;#39; @importFrom ggplot2 aes_
...
##&amp;#39; @export
##&amp;#39; @author Guangchuang Yu
##&amp;#39; @references \url{http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;roxygen会根据这一部分对单一函数生成帮助文档，也就是我们在R命令行中输入&lt;code&gt;?FunctionName&lt;/code&gt;看到的帮助信息。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/roxygen.png&#34; alt=&#34;渲染后的帮助文档&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;渲染后的帮助文档&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其基础格式是（Y叔使用了&lt;code&gt;##&#39;&lt;/code&gt;，我觉得好像跟&lt;code&gt;#&#39;&lt;/code&gt;没有什么区别？）：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#&amp;#39; @param 函数参数（对应Arguments） 函数的介绍（对应Description）&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的注释大多可以顾名思义。比较有意思的是&lt;code&gt;#&#39; @export&lt;/code&gt;这行了，roxygen会把这个函数放在&lt;code&gt;NAMESPACE&lt;/code&gt;文件中，这样用户便可以调用这个函数。我是可以调用&lt;code&gt;yyplot::geom_ord_ellipse()&lt;/code&gt;这个函数的。但&lt;code&gt;yyplot:StatOrdEllipse()&lt;/code&gt;这个函数是yyplot的内部函数（注意代码中此函数没有&lt;code&gt;#&#39; @export&lt;/code&gt;注释）。如果我调用就会报错：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yyplot::StatOrdEllipse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Error: &amp;#39;StatOrdEllipse&amp;#39; is not an exported object from &amp;#39;namespace:yyplot&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多关于roxygen的介绍可以参考&lt;a href=&#34;http://kbroman.org/pkg_primer/pages/docs.html&#34;&gt;这篇文章&lt;/a&gt;或&lt;a href=&#34;https://github.com/klutometis/roxygen&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ggprotoggplot2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;ggproto&lt;/code&gt;–&lt;code&gt;ggplot2&lt;/code&gt;的语言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ggplot2.tidyverse.org/reference/ggproto.html&#34;&gt;ggproto&lt;/a&gt;是ggplot2模块化、面向对象（Object Oriented）化的核心部分。基础的格式是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggproto(`_class` = NULL, `_inherit` = NULL, ...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ggproto&lt;/code&gt;是一个很庞大的系统，我目前理解还不是很深入，提供一些参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rdocumentation.org/packages/ggplot2/versions/2.2.1/topics/ggplot2-ggproto&#34;&gt;官方详细文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html&#34;&gt;ggproto教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在理解Y叔这个脚本中我们需要使用最基础的两个模块&lt;code&gt;Geom&lt;/code&gt;（创建图层），&lt;code&gt;Stat&lt;/code&gt;（数据处理）。&lt;/p&gt;
&lt;div id=&#34;statordellipseggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;StatOrdEllipse&lt;/code&gt;内部函数–&lt;code&gt;ggplot2&lt;/code&gt;中的数据处理&lt;/h3&gt;
&lt;p&gt;我们在作图之前基本都是要对输入数据进行一些数据预处理，比如在做线箱图的时候需要计算中位数、IQR等。在这个脚本中，我们需要做的是计算置信区间椭圆，这一步是通过&lt;code&gt;ggplot::Stat&lt;/code&gt;实现的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;StatOrdEllipse &amp;lt;- ggproto(&amp;quot;StatOrdEllipse&amp;quot;, Stat,
                          compute_group = function(self, data, scales, params, ellipse_pro) {
                              ## 此处省略...
                              ## 解析见后文
                              return(ell)
                          },
                          required_aes = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;group&amp;quot;)
                          )&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_class&lt;/code&gt;：这个类的名字为&lt;code&gt;StatOrdEllipse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_inherit&lt;/code&gt;：继承&lt;code&gt;Stat&lt;/code&gt;类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compute_group&lt;/code&gt;：核心处理数据部分，对每一组进行处理，模板为&lt;code&gt;compute_group(self, data, scales, ...)&lt;/code&gt;，在这里，它主要接受置信区间（&lt;code&gt;ellipse_pro&lt;/code&gt;）参数，返回值为&lt;strong&gt;计算好的置信区间轮廓上的点坐标&lt;/strong&gt;。&lt;em&gt;另外，我认为这里&lt;code&gt;params&lt;/code&gt;并不必要&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;required_aes&lt;/code&gt;：创建图层所需要的mapping参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;geom_ord_ellipseggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;geom_ord_ellipse&lt;/code&gt;函数–创建&lt;code&gt;ggplot2&lt;/code&gt;图层&lt;/h3&gt;
&lt;p&gt;下面便是重头戏，使用上面的&lt;code&gt;Stat&lt;/code&gt;来创建一个&lt;code&gt;Geom&lt;/code&gt;图层。其实这就是一个普通的函数，只是为了返回一个图层&lt;code&gt;layer&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;geom_ord_ellipse &amp;lt;- function(mapping = NULL, ellipse_pro = 0.97, fill = NA, ...) {
    default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)
    if (is.null(mapping)) {
        mapping &amp;lt;- default_aes
    } else {
        mapping &amp;lt;- modifyList(default_aes, mapping)
    }
    layer(
        geom = &amp;quot;polygon&amp;quot;,
        stat = StatOrdEllipse,
        mapping = mapping,
        position = &amp;#39;identity&amp;#39;,
        data = NULL,
        params = list(
            ellipse_pro = ellipse_pro,
            fill = fill,
            ...
        )
    )
}&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;函数的输入值：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mapping&lt;/code&gt;：使用过ggplot2都不应该陌生，就是我们写的&lt;code&gt;aes(x=, y=)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ellipse_pro&lt;/code&gt;：置信区间的概率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt;：置信区间内部的颜色，&lt;code&gt;NA&lt;/code&gt;会产生透明的椭圆&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;输入预处理：&lt;/h4&gt;
&lt;p&gt;这里对输入的&lt;code&gt;mapping&lt;/code&gt;做了判断，如果没有输入，就会使用默认值，如果有输入，则替换默认值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default_aes &amp;lt;- aes_(color = ~Groups, group = ~Groups)&lt;/code&gt;：定义了默认的aesthetics，使用&lt;code&gt;aes_&lt;/code&gt;时，变量要用双引号引用或使用&lt;code&gt;~&lt;/code&gt;（&lt;code&gt;~Groups&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modifyList&lt;/code&gt;：根据一个&lt;code&gt;list&lt;/code&gt;修改另一个&lt;code&gt;list&lt;/code&gt;中的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;ggplotlayer&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;返回的&lt;code&gt;ggplot::layer&lt;/code&gt;：&lt;/h4&gt;
&lt;p&gt;这个函数的模板是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;layer(geom = NULL, stat = NULL, data = NULL, mapping = NULL,
  position = NULL, params = list(), inherit.aes = TRUE,
  check.aes = TRUE, check.param = TRUE, subset = NULL, show.legend = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应到Y叔的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;geom = &amp;quot;polygon&amp;quot;&lt;/code&gt;：一个多边形（椭圆）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stat = StatOrdEllipse&lt;/code&gt;：使用我们定义的&lt;code&gt;Stat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapping = mapping&lt;/code&gt;：数据与图形的对应，如&lt;code&gt;x=, y=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position = &#39;identity&#39;&lt;/code&gt;：位置的定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data = NULL&lt;/code&gt;：从上一图层继承&lt;/li&gt;
&lt;li&gt;&lt;code&gt;params = list(...)&lt;/code&gt;：&lt;code&gt;geom&lt;/code&gt;和&lt;code&gt;stat&lt;/code&gt;的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里，对于一些基本的图层，我觉得完全可以套用Y叔的这个模板。在宏基因组公众号中曾经有人问，这个&lt;code&gt;ggord&lt;/code&gt;包中能不能把那些向量去掉，或者加入少部分变量的向量，我想用这个模板完全可以实现，只需要用&lt;code&gt;GeomCurve&lt;/code&gt;来做个图层就可以了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;计算置信区间椭圆&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(data)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
circle &amp;lt;- cbind(cos(theta), sin(theta))
ell &amp;lt;- ddply(data, .(group), function(x) {
   if(nrow(x) &amp;lt;= 2) {
       return(NULL)
   }
   sigma &amp;lt;- var(cbind(x$one, x$two))
   mu &amp;lt;- c(mean(x$one), mean(x$two))
   ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
   data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
    })
names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])  
names(ell) &amp;lt;- c(&amp;#39;Groups&amp;#39;, &amp;#39;x&amp;#39;, &amp;#39;y&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个代码是从&lt;code&gt;ggord&lt;/code&gt;的源码改过来的。对于排序图来说，基本最后都会降维到一个低维的空间（2维），方便展示。所以，我们最后需要处理的问题就是根据2维上的散点，计算出这些点分布的可能范围（在2维正态分布的假设下，对协方差使用卡方检验）。其中涉及到我们要把数据分成组（不同椭圆，不同颜色标记），然后对每一组求出上述的范围。这个操作使用ddply实现的：&lt;/p&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;分而治之&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ell &amp;lt;- ddply(data, .(group), function(x) {
    ## ...
    ## 解析见后文
    })&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在此，把&lt;code&gt;data&lt;/code&gt;根据&lt;code&gt;group&lt;/code&gt;拆分成组，然后每一组套用&lt;code&gt;function&lt;/code&gt;，最后再把结果组合（&lt;code&gt;rbind&lt;/code&gt;）在一起。以下我们介绍每一组是如何处理的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;计算置信椭圆&lt;/h4&gt;
&lt;p&gt;从统计上来讲这个置信椭圆是这样做的：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;做出一个单位圆（半径为单位1）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
## should be:
## theta &amp;lt;- seq(-pi, pi, length = 50)
circle &amp;lt;- cbind(cos(theta), sin(theta))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们知道单位圆的参数方程为&lt;span class=&#34;math inline&#34;&gt;\(x=\cos(\theta), y=\sin(\theta),\theta\in[0,2\pi]\)&lt;/span&gt;，在这里ggord的作者其实重复了两圈，具体的原因我也没有搞清楚，我认为&lt;em&gt;没有必要&lt;/em&gt;。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;套用公式把这个圆转换成椭圆&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sigma &amp;lt;- var(cbind(x$one, x$two))
mu &amp;lt;- c(mean(x$one), mean(x$two))
ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的转化实际是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X_{ell}=\boldsymbol\mu + k\boldsymbol X C(\boldsymbol\Sigma)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol\mu=(\bar x_1,\bar x_2)\)&lt;/span&gt;，也就是数据的中心，&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;根据概率控制椭圆的大小（因为是针对2维正态分布的协方差，所以使用了卡方检验），&lt;span class=&#34;math inline&#34;&gt;\(C(\boldsymbol\Sigma)\)&lt;/span&gt;代表协方差矩阵的Cholesky分解，&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\boldsymbol X_{ell}\)&lt;/span&gt;分别为圆和椭圆上对应点的坐标。&lt;/p&gt;
&lt;p&gt;至于为什么这么做，涉及一些线代推导，可以参见下面两篇文章（特别是第一篇）：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://jellymatter.wordpress.com/2011/03/31/drawing-confidence-ellipses-and-ellipsoids/#more-507&#34; class=&#34;uri&#34;&gt;https://jellymatter.wordpress.com/2011/03/31/drawing-confidence-ellipses-and-ellipsoids/#more-507&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/&#34; class=&#34;uri&#34;&gt;http://www.visiondummy.com/2014/04/draw-error-ellipse-representing-covariance-matrix/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;section level4&#34;&gt;
&lt;h4&gt;有点多余？&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
ell &amp;lt;- ddply(ell, .(group), function(x) x[chull(x$one, x$two), ])  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这部分的意思是对之前算出的那些椭圆上的点找出对应的凸多边形。我认为对于上述方法得到的点已经在一个凸多边形上了（椭圆）。我没有太明白这一步的必要性，&lt;em&gt;去掉之后并没有发现影响&lt;/em&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Useful commands for Docker</title>
      <link>/post/2017-12-31-bioinfo-docker_notes/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-31-bioinfo-docker_notes/</guid>
      <description>&lt;section id=&#34;docker&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;改变Docker容器存储路径&lt;/h2&gt;
&lt;p&gt;Linux下Docker的默认存储目录为&lt;code&gt;/var/lib/docker&lt;/code&gt;。显然这个目录属于&lt;code&gt;root&lt;/code&gt;分区（如果安装时进行过分区的话）。而一般这个分区会较小，我们更希望把容器和镜像存储于&lt;code&gt;/home&lt;/code&gt;下。我根据这篇博客进行了更改&lt;a href=&#34;https://sanenthusiast.com/change-default-image-container-location-docker/&#34; class=&#34;uri&#34;&gt;https://sanenthusiast.com/change-default-image-container-location-docker/&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;docker&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Docker常用操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加载镜像：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;gunzip -c [docker.img.tar.gz] | docker load

docker pull [docker_image_name]

cat [docker_file] | docker build -t [image_name] -&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启动容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;# 基本命令
docker run -it [image_name] 
# 退出时删除容器，加载host的文件路径
docker run -it --rm -v /host/directory:/container/directory [image_name]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;attach&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker attach [container_name/container_hash_ID]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;detach（容器在后台运行）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ctrl+p Ctrl+q&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出所有容器（包括未在运行中的）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker ps -a 
docker rm [container] # 删除容器&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;列出所有镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker images
docker rmi [image] # 删除镜像&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;host和容器文件转移&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker cp [source] [target] # use container hash id or name &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Commit&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;docker commit [container_name/container_hash_ID] [image_ID/image_name:image_tag]&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Add confidence ellipse to LDA ordination plot II</title>
      <link>/post/2017-12-29-r-addconfellipse/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-29-r-addconfellipse/</guid>
      <description>&lt;section class=&#34;level2&#34;&gt;
&lt;h2&gt;为排序图添加置信范围曲线&lt;/h2&gt;
&lt;p&gt;上一篇&lt;a href=&#34;http://lchblogs.netlify.com/post/2017-12-22-r-addconfellipselda/&#34;&gt;文章&lt;/a&gt;我们利用&lt;a href=&#34;https://github.com/fawda123/ggord&#34;&gt;ggord&lt;/a&gt;的源代码改写了一个为LDA排序图添加置信曲线的函数，现在&lt;a href=&#34;https://guangchuangyu.github.io/&#34;&gt;Y叔&lt;/a&gt;已经把它改写成了一个geom添加在了他的&lt;a href=&#34;https://github.com/GuangchuangYu/yyplot&#34;&gt;yyplot&lt;/a&gt;包中。y叔扩展了它的功能，现在支持ggord中的其他排序图（我没有进行全面的测试）。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggord)
library(yyplot)
library(MASS)&lt;/code&gt;&lt;/pre&gt;
&lt;section id=&#34;lda&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;LDA&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- lda(Species ~ ., iris, prior = rep(1, 3)/3)
ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/lda-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;pca&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;PCA&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- prcomp(iris[, 1:4])
ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/pca-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;mds&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;MDS&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(vegan)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: permute&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: lattice&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## This is vegan 2.4-4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ord &amp;lt;- metaMDS(iris[, 1:4])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Run 0 stress 0.03775523 
## Run 1 stress 0.05879963 
## Run 2 stress 0.05771902 
## Run 3 stress 0.03775576 
## ... Procrustes: rmse 6.70624e-05  max resid 0.0002355622 
## ... Similar to previous best
## Run 4 stress 0.0599531 
## Run 5 stress 0.04367524 
## Run 6 stress 0.05537389 
## Run 7 stress 0.03775524 
## ... Procrustes: rmse 9.47124e-06  max resid 4.820747e-05 
## ... Similar to previous best
## Run 8 stress 0.03775578 
## ... Procrustes: rmse 2.073778e-05  max resid 0.000125111 
## ... Similar to previous best
## Run 9 stress 0.04367554 
## Run 10 stress 0.03775534 
## ... Procrustes: rmse 1.898558e-05  max resid 5.211088e-05 
## ... Similar to previous best
## Run 11 stress 0.04367546 
## Run 12 stress 0.06174009 
## Run 13 stress 0.04367526 
## Run 14 stress 0.0377554 
## ... Procrustes: rmse 3.074059e-05  max resid 0.0001171343 
## ... Similar to previous best
## Run 15 stress 0.05093855 
## Run 16 stress 0.05398536 
## Run 17 stress 0.03775584 
## ... Procrustes: rmse 7.169048e-05  max resid 0.0002630254 
## ... Similar to previous best
## Run 18 stress 0.03775551 
## ... Procrustes: rmse 4.556503e-05  max resid 0.0001590274 
## ... Similar to previous best
## Run 19 stress 0.04804016 
## Run 20 stress 0.04355825 
## *** Solution reached&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggord(ord, iris$Species) + geom_ord_ellipse(lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-29-r-addConfEllipse_files/figure-html/mds-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Add confidence ellipse to LDA ordination plot</title>
      <link>/post/2017-12-22-r-addconfellipselda/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-12-22-r-addconfellipselda/</guid>
      <description>&lt;section id=&#34;use-ggord-to-plot-lda-ordination-plot&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Use ggord to plot LDA ordination plot&lt;/h2&gt;
&lt;section id=&#34;installation&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;#39;fawda123/ggord&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;basic-lda-ordination-biplot&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;Basic LDA ordination biplot&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(MASS)
ord &amp;lt;- lda(Species ~ ., iris, prior = rep(1, 3)/3)

library(ggord)
p &amp;lt;- ggord(ord, iris$Species)
p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-22-r-addConfEllipseLDA_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&#34;a-function-to-compute-confidence-ellipse&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;A function to compute confidence ellipse&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_lda_ell &amp;lt;- function(ord_in, grp_in, ellipse_pro = 0.97){
    ## adapted from https://github.com/fawda123/ggord/blob/master/R/ggord.R
    require(plyr)
    axes = c(&amp;#39;LD1&amp;#39;, &amp;#39;LD2&amp;#39;)
    obs &amp;lt;- data.frame(predict(ord_in)$x[, axes])
    obs$Groups &amp;lt;- grp_in
    names(obs)[1:2] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
    theta &amp;lt;- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
    circle &amp;lt;- cbind(cos(theta), sin(theta))
    ell &amp;lt;- ddply(obs, &amp;#39;Groups&amp;#39;, function(x) {
        if(nrow(x) &amp;lt;= 2) {
            return(NULL)
        }
        sigma &amp;lt;- var(cbind(x$one, x$two))
        mu &amp;lt;- c(mean(x$one), mean(x$two))
        ed &amp;lt;- sqrt(qchisq(ellipse_pro, df = 2))
        data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = &amp;#39;+&amp;#39;))
    })
    names(ell)[2:3] &amp;lt;- c(&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;)
    ell &amp;lt;- ddply(ell, .(Groups), function(x) x[chull(x$one, x$two), ])
    ell
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;using-the-function&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Using the function&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
anotherEll &amp;lt;- get_lda_ell(ord, iris$Species, 0.97)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: plyr&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + geom_polygon(data = anotherEll, 
                 aes_string(color = &amp;#39;Groups&amp;#39;, group = &amp;#39;Groups&amp;#39;),
                 lty=2, fill = NA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-22-r-addConfEllipseLDA_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>有了绝对定量就完了？</title>
      <link>/post/2017-11-18-r-absolute/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-11-18-r-absolute/</guid>
      <description>&lt;section class=&#34;level2&#34;&gt;
&lt;h2&gt;微生物组研究走向绝对定量&lt;/h2&gt;
&lt;p&gt;Jeroen Raes研究组上周在Nature发表&lt;a href=&#34;https://www.nature.com/articles/nature24460&#34;&gt;文章&lt;/a&gt;，使用Flow cytometry估算粪便中的微生物细胞数量，配合16S测序算出的相对丰度，估算出OTU的绝对数量（absolute abundance）。文章很多结论都印证了直接应用相对丰度进行分析时，我们所看到的很多现象是成分数据性质的假象（可以想象，由于相对丰度在每一个样本中相加为1或100，一个OTU相对丰度增加必将引起其他OTU相对丰度减少，所谓的compositional bias）。特别针对于计算两个OTU的相关系数，当OTU分布不均匀时，很容易看到负相关的OTU–而这仅仅是因为它们受到相加为常数的限制而已。另一个典型例子就是主成分分析（PCA），PCA意在保持欧式距离不变的情况下对数据进行变换，但是相对丰度其实不在欧式空间中（可以参考:J. Aitchison, The Statistical Analysis of Compositional Data, 1986.），这就是为什么在微生物组的研究中更多采用生态学的距离（如，Bray-Curtis distance）来计算&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; -diversity，然后进行基于距离矩阵的分析（PCoA）。&lt;/p&gt;
&lt;p&gt;似乎文章的take home message很简单了，微生物组的研究，我们应该使用类似的方法进行绝对定量。可是仔细想一想，文章指出粪便微生物总量的个体差异可以达到10倍之多，这样大的差异，如果某种微生物在个体之间差异很小，转换成绝对数量之后，个体间的差异将受制于微生物总量。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;flow-cytometryvariation&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;使用Flow cytometry测定的肠道微生物总量的variation有多大？&lt;/h2&gt;
&lt;p&gt;下载Nature文章中的&lt;a href=&#34;https://images.nature.com/original/nature-assets/nature/journal/vaop/ncurrent/extref/nature24460-s2.xlsx&#34;&gt;Supplementary Table&lt;/a&gt;，这里并不不需要购买文章阅读权限，其中表6是Flow cytometry的数据。&lt;/p&gt;
&lt;section id=&#34;rggplot2&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;加载R包，ggplot2主题&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ─────────────────────────────────────────────────────────── tidyverse 1.2.1 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ ggplot2 2.2.1     ✔ purrr   0.2.4
## ✔ tibble  1.3.4     ✔ dplyr   0.7.4
## ✔ tidyr   0.7.2     ✔ stringr 1.2.0
## ✔ readr   1.1.1     ✔ forcats 0.2.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;data.table&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:dplyr&amp;#39;:
## 
##     between, first, last&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:purrr&amp;#39;:
## 
##     transpose&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(cowplot)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;cowplot&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:ggplot2&amp;#39;:
## 
##     ggsave&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(readxl)

figtheme &amp;lt;- theme_bw() + 
  theme(text = element_text(size=10,face=&amp;#39;bold&amp;#39;),panel.border  = element_rect(colour = &amp;quot;black&amp;quot;,size=2),
        axis.title.y=element_text(margin=margin(0,15,0,0)),axis.title.x=element_text(margin=margin(15,0,0,0)),
        plot.margin = unit(c(1,1,1,1), &amp;quot;cm&amp;quot;),
        plot.title = element_text(margin=margin(0,0,15,0)))
theme_set(figtheme)&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;6&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;读取表6，并预处理&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_counts_dat &amp;lt;- read_excel(&amp;#39;~/nature24460-s2.xlsx&amp;#39;, sheet=6) %&amp;gt;%
  mutate(Cohort=gsub(&amp;#39;[0-9]+&amp;#39;,&amp;#39;&amp;#39;,Individual)) %&amp;gt;%
  mutate(Cell_count_avg=`Average cell count (per gram of frozen feces)`)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in strptime(x, format, tz = tz): unknown timezone &amp;#39;zone/tz/2017c.
## 1.0/zoneinfo/Asia/Singapore&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_counts_dat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 321 x 10
##    Individual Cohort   Day `Health status`
##         &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;           &amp;lt;chr&amp;gt;
##  1       SC01     SC     1         Healthy
##  2       SC02     SC     1         Healthy
##  3       SC03     SC     1         Healthy
##  4       SC04     SC     1         Healthy
##  5       SC05     SC     1         Healthy
##  6       SC06     SC     1         Healthy
##  7       SC07     SC     1         Healthy
##  8       SC08     SC     1         Healthy
##  9       SC09     SC     1         Healthy
## 10       SC10     SC     1         Healthy
## # ... with 311 more rows, and 6 more variables: `Average cell count (per
## #   gram of fresh feces)` &amp;lt;chr&amp;gt;, `STDEV cell count (per gram of fresh
## #   feces)` &amp;lt;chr&amp;gt;, `Average cell count (per gram of frozen feces)` &amp;lt;dbl&amp;gt;,
## #   `STDEV cell count (per gram of frozen feces)` &amp;lt;chr&amp;gt;, Enterotype &amp;lt;chr&amp;gt;,
## #   Cell_count_avg &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section class=&#34;level3&#34;&gt;
&lt;h3&gt;微生物总量差异&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;个体差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aggregate(data=cell_counts_dat, Cell_count_avg~Cohort, function(x) c(Mean=mean(x), SD=sd(x), CV=sd(x)/mean(x)) )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Cohort Cell_count_avg.Mean Cell_count_avg.SD Cell_count_avg.CV
## 1     DC        9.092967e+10      6.344747e+10      6.977642e-01
## 2     LC        1.249278e+11      5.406697e+10      4.327858e-01
## 3     SC        1.528339e+11      7.018824e+10      4.592451e-01
## 4     VC        1.447904e+11      7.630896e+10      5.270304e-01&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(cell_counts_dat, aes(x=Cohort, y=Cell_count_avg)) + geom_boxplot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-18-r-absolute_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个体内差异&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aggregate(data=cell_counts_dat[cell_counts_dat$Cohort==&amp;#39;LC&amp;#39;,], Cell_count_avg~Individual, function(x) c(Mean=mean(x), SD=sd(x), CV=sd(x)/mean(x)) )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Individual Cell_count_avg.Mean Cell_count_avg.SD Cell_count_avg.CV
## 1        LC01        1.121069e+11      3.062958e+10      2.732175e-01
## 2        LC02        1.057725e+11      1.457955e+10      1.378387e-01
## 3        LC03        6.998669e+10      3.207140e+10      4.582500e-01
## 4        LC04        6.433548e+10      1.478855e+10      2.298661e-01
## 5        LC05        2.198245e+11      2.726579e+10      1.240343e-01
## 6        LC06        2.054927e+11      4.951278e+10      2.409466e-01
## 7        LC07        1.197242e+11      3.438372e+10      2.871911e-01
## 8        LC08        1.162890e+11      3.286685e+10      2.826307e-01
## 9        LC09        1.501435e+11      6.018554e+10      4.008535e-01
## 10       LC10        1.790086e+11      8.293900e+10      4.633241e-01
## 11       LC11        1.565348e+11      4.038210e+10      2.579752e-01
## 12       LC12        1.247153e+11      2.494971e+10      2.000533e-01
## 13       LC13        9.804859e+10      2.625298e+10      2.677548e-01
## 14       LC14        1.037225e+11      4.329933e+10      4.174534e-01
## 15       LC15        1.592359e+11      2.337419e+10      1.467897e-01
## 16       LC16        1.171450e+11      6.207212e+10      5.298741e-01
## 17       LC17        1.215423e+11      3.782074e+10      3.111736e-01
## 18       LC18        1.042144e+11      4.236728e+10      4.065395e-01
## 19       LC19        7.013542e+10      2.326036e+10      3.316492e-01
## 20       LC20        1.465100e+11      2.763866e+10      1.886470e-01&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(cell_counts_dat[cell_counts_dat$Cohort==&amp;#39;LC&amp;#39;,], aes(x=Day, y=Cell_count_avg)) + geom_line() + facet_wrap(~Individual)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-18-r-absolute_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;容易看出，疾病组（DC）的微生物总量最低，其他几个健康组微生物总量差异不大，而个人的微生物总量在一周内的变化要小一些（CV~30%），但其实比起个体间差异不是小很多。&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&#34;variation&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;人的肠道微生物相对丰度的variation有多大？&lt;/h2&gt;
&lt;section id=&#34;hmp&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;下载人类微生物组项目（HMP）数据&lt;/h3&gt;
&lt;p&gt;我们使用HMPv35的16S的&lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/otu_table_psn_v35.txt.gz&#34;&gt;OTU table&lt;/a&gt;和元数据表(&lt;a href=&#34;ftp://public-ftp.ihmpdcc.org/HMQCP/v35_map_uniquebyPSN.txt.bz2&#34;&gt;mapping file&lt;/a&gt;)。下载之后解压。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;0otu&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;清洗数据，保留肠道数据并去掉整行为0的OTU&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;metadata &amp;lt;- fread(&amp;#39;~/v35_map_uniquebyPSN.txt&amp;#39;)
stoolIDs &amp;lt;- as.character((metadata %&amp;gt;% filter(HMPbodysubsite==&amp;#39;Stool&amp;#39;))[,1])

otutab &amp;lt;- fread(&amp;#39;~/otu_table_psn_v35.txt&amp;#39;,head=TRUE, select=stoolIDs,sep=&amp;#39;\t&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select =
## stoolIDs, : Starting data input on line 2 and discarding line 1 because it
## has too few or too many items to be column names or data: # QIIME v1.3.0-
## dev OTU table&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select =
## stoolIDs, : Column name &amp;#39;700107040&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in fread(&amp;quot;~/otu_table_psn_v35.txt&amp;quot;, head = TRUE, select =
## stoolIDs, : Column name &amp;#39;700114489&amp;#39; not found in column name header (case
## sensitive), skipping.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
Read 44.1% of 45383 rows
Read 45383 rows and 319 (of 4790) columns from 0.409 GB file in 00:00:04&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## keep samples with counts &amp;gt; 2000
otutab &amp;lt;- otutab %&amp;gt;% select(which(colSums(otutab)&amp;gt; 2000 ))
## we down sample (rarefy) the samples to have 2000 counts in total
otutab_rare &amp;lt;- apply(otutab, 2, function(x) rmultinom(1,size=2000, prob=x))
## remove OTUs not present at all and normalize to proportions
otutab_rel &amp;lt;- apply(otutab_rare[rowSums(otutab_rare)!=0,], 2, function(x)x/sum(x))&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;sd-cv-mean&#34; class=&#34;level3&#34;&gt;
&lt;h3&gt;SD, CV, Mean&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SD &amp;lt;- apply(otutab_rel,1,sd)
Mean &amp;lt;- apply(otutab_rel, 1, mean)
tmp &amp;lt;- data.frame(CV=SD/Mean, Mean, SD)
g1 &amp;lt;- ggplot(tmp, aes(y=SD, x=Mean)) + 
  geom_point(alpha=0.1) + 
  scale_x_log10()  + scale_y_log10() + 
  annotation_logticks(sides = &amp;#39;lb&amp;#39;)
g2 &amp;lt;- ggplot(tmp, aes(y=CV, x=Mean)) + 
  geom_point(alpha=0.1) + 
  scale_x_log10()   + 
  annotation_logticks(sides = &amp;#39;b&amp;#39;)
plot_grid(g1, g2, nrow=1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-18-r-absolute_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从CV来看，HMP的数据相对丰度其实在个体间差距比较大（特别是低丰度的OTU，可以想象这是跟0的数量多有关），所以可能大多数情况下，我们不会受到总量变化（CV~50%）的影响。&lt;strong&gt;Note: &lt;/strong&gt;还是需要注意在我们的研究数据中会不会&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id=&#34;a-thought-experiment&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;绝对定量的分析，A thought experiment&lt;/h2&gt;
&lt;p&gt;正态分布的随机变量（&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;）分别代表微生物总量（&lt;span class=&#34;math inline&#34;&gt;\(M\sim|Normal(10^{11},CV_m\times10^{11}|)\)&lt;/span&gt;），微生物&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;的相对丰度（&lt;span class=&#34;math inline&#34;&gt;\(X\sim| Normal(10^{-1},CV_x \times10^{-1})|\)&lt;/span&gt;），那么绝对数量&lt;span class=&#34;math inline&#34;&gt;\(MX\)&lt;/span&gt;会与&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;相关吗？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;M &amp;lt;- abs(rnorm(1000, 1e11, 0.5e11)) ## CV=0.5
X &amp;lt;- sapply(c(0.1,0.5,1,5,10), function(x)abs(rnorm(1000, 0.1, x*0.1)))   
colnames(X) &amp;lt;- c(&amp;#39;X_cv0.1&amp;#39;,&amp;#39;X_cv0.5&amp;#39;,&amp;#39;X_cv1&amp;#39;, &amp;#39;X_cv5&amp;#39;, &amp;#39;X_cv10&amp;#39;)
dat &amp;lt;- melt(X)%&amp;gt;% mutate(MX=value*M) %&amp;gt;% mutate(M=rep(M,5))

dat %&amp;gt;% group_by(Var2) %&amp;gt;% summarise(cor(MX, M, method=&amp;#39;spearman&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
##      Var2 `cor(MX, M, method = &amp;quot;spearman&amp;quot;)`
##    &amp;lt;fctr&amp;gt;                             &amp;lt;dbl&amp;gt;
## 1 X_cv0.1                         0.9745780
## 2 X_cv0.5                         0.6241846
## 3   X_cv1                         0.4850720
## 4   X_cv5                         0.5014045
## 5  X_cv10                         0.4692217&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dat,aes(x=M,y=MX)) + 
  geom_point(alpha=0.4) + 
  facet_wrap(~Var2, nrow=2, scale=&amp;#39;free_y&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-18-r-absolute_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以不难看出来微生物的绝对数量与微生物总量相关，特别是当相对丰度差异不大的时候。So what？记得correlation有传递性吗？所以如果有两个不相关的微生物，它们的绝对数量会不会因为总量而变得相关呢？我们根据&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;的分布生成另一个独立的随机变量&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;，让我们来看下他们的correlation是怎样的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Y &amp;lt;- sapply(c(0.1,0.5,1,5,10), function(x)abs(rnorm(1000, 0.1, x*0.1))) 
colnames(Y) &amp;lt;- c(&amp;#39;Y_cv0.1&amp;#39;,&amp;#39;Y_cv0.5&amp;#39;,&amp;#39;Y_cv1&amp;#39;, &amp;#39;Y_cv5&amp;#39;, &amp;#39;Y_cv10&amp;#39;)
dat &amp;lt;- dat %&amp;gt;% mutate(Y=melt(Y)$value) %&amp;gt;% mutate(MY=M*Y)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;毫无关联的&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;,&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dat %&amp;gt;% group_by(Var2) %&amp;gt;% summarise(cor(value, Y, method=&amp;#39;spearman&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
##      Var2 `cor(value, Y, method = &amp;quot;spearman&amp;quot;)`
##    &amp;lt;fctr&amp;gt;                                &amp;lt;dbl&amp;gt;
## 1 X_cv0.1                          0.039534460
## 2 X_cv0.5                          0.025382017
## 3   X_cv1                          0.039640060
## 4   X_cv5                          0.015882484
## 5  X_cv10                          0.002462222&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;转化成绝对数量后&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dat %&amp;gt;% group_by(Var2) %&amp;gt;% 
  summarise(Spearman_rho=cor(MX, MY, method=&amp;#39;spearman&amp;#39;),
            p_value=cor.test(MX, MY, method=&amp;#39;spearman&amp;#39;)$p.value)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 3
##      Var2 Spearman_rho      p_value
##    &amp;lt;fctr&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
## 1 X_cv0.1    0.9509044 0.000000e+00
## 2 X_cv0.5    0.4455341 0.000000e+00
## 3   X_cv1    0.3194627 0.000000e+00
## 4   X_cv5    0.2866312 2.842296e-20
## 5  X_cv10    0.2930657 3.241526e-21&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;散点图&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dat,aes(x=MX,y=MY)) + 
  geom_point(alpha=0.4) + 
  facet_wrap(~Var2, nrow=2, scale=&amp;#39;free&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-18-r-absolute_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section class=&#34;level2&#34;&gt;
&lt;h2&gt;相关性？为什么相关？&lt;/h2&gt;
&lt;p&gt;所以在以上的实验当中，不难看出即使不相关的两个OTU，因为个体差异不大，转化为绝对数量之后很有可能呈现相关性，而这样的相关性跟生态意义毫无关系，只是因为latent variable微生物总量而已（Nature文章的Figure 3）。&lt;/p&gt;
&lt;p&gt;延展开来，当你发现某些微生物的绝对数量和某种表征相关的时候，也需要考虑一下，它们是否只是因为微生物总量的不同呢（Nature文章的Figure 4）？&lt;/p&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Generalized Lotka-Volterra model</title>
      <link>/post/2017-11-15-r-glv/</link>
      <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-11-15-r-glv/</guid>
      <description>&lt;section id=&#34;the-model&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;The model&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\frac{dx_i}{dt}= ax_i+\sum_{j=1}^pb_{ij}x_ix_j\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## library
library(&amp;#39;deSolve&amp;#39;)
## GLV function
lvm &amp;lt;- function(t, x, params){
  with(as.list(params, c(x)), {
    dx &amp;lt;- alpha * x + x * (beta %*% x)
    list(dx)
  })
}

## numerical integration
n.integrate &amp;lt;- function(time, init.x, model, params){
    as.data.frame(ode(init.x, time, model, params))
}
## normalizations
TSS &amp;lt;- function(x){
  apply(x, 1, function(x)x/sum(x))
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id=&#34;glv-with-3-species&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;GLV with 3 species&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;alpha &amp;lt;- c(0.1, 0.2, 0.3)
beta &amp;lt;- t(matrix(c(-0.5, -0.3 ,   0, 
                    0.1, -0.5 ,   0,
                     0 ,   0  , -0.5), 
                 3,3 ))

init.x &amp;lt;- c(0.6, 1, 0.4)

dat &amp;lt;- n.integrate(0:10, init.x, lvm, list(alpha=alpha, beta=beta))
dat.norm &amp;lt;- t(TSS(dat[,-1]))

par(mfrow=c(1,2))
matplot(x=dat$time, y=dat[,-1], typ=&amp;#39;b&amp;#39;, xlab=&amp;#39;time&amp;#39;, ylab=&amp;#39;Absolute abundance&amp;#39;) ## absolute abundance
matplot(x=dat$time, y=dat.norm, typ=&amp;#39;b&amp;#39;, xlab=&amp;#39;time&amp;#39;, ylab=&amp;#39;Relative abundance&amp;#39;) ## relative abundance&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-15-r-GLV_files/figure-html/sample_data-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;scale-parameters&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Scale parameters&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;init.x.scaled &amp;lt;- init.x/sum(init.x)
beta.scaled &amp;lt;- beta * sum(init.x)

dat.w_scaled_beta &amp;lt;- n.integrate(0:10, init.x.scaled, lvm, list(alpha=alpha, beta=beta.scaled))
dat.norm.w_scaled_beta &amp;lt;- t(TSS(dat.w_scaled_beta[,-1]))

par(mfrow=c(1,2))
matplot(x=dat.w_scaled_beta$time, y=dat.w_scaled_beta[,-1], typ=&amp;#39;b&amp;#39;, xlab=&amp;#39;time&amp;#39;, ylab=&amp;#39;Absolute abundance&amp;#39;) ## absolute abundance
matplot(x=dat.w_scaled_beta$time, y=dat.norm.w_scaled_beta, typ=&amp;#39;b&amp;#39;, xlab=&amp;#39;time&amp;#39;, ylab=&amp;#39;Relative abundance&amp;#39;) ## relative abundance&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-15-r-GLV_files/figure-html/scaled_data-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;compare&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Compare&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow=c(1,2))
matplot(dat.w_scaled_beta[,-1]/dat[,-1], type=&amp;#39;b&amp;#39;, ylab=&amp;#39;Ratio of abundance trajectories&amp;#39;)
matplot(dat.norm.w_scaled_beta - dat.norm, type=&amp;#39;b&amp;#39;, ylab=&amp;#39;Absolute Error in Relative Abundances&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-11-15-r-GLV_files/figure-html/compare-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;conclusion&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It turned out that the GLV model could be scaled as long as the abundances and the interaction matrix were compatible (scale abundances by a factor of &lt;span class=&#34;math inline&#34;&gt;\(c\)&lt;/span&gt;, then interaction matrix scaled by a factor of &lt;span class=&#34;math inline&#34;&gt;\(1/c\)&lt;/span&gt;).&lt;/p&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
