<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chenhao&#39;s Personal Page on Chenhao&#39;s Personal Page</title>
    <link>/</link>
    <description>Recent content in Chenhao&#39;s Personal Page on Chenhao&#39;s Personal Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© This site was created with R BlogDown and HuGo by Chenhao Li.</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Telegram bot基础使用</title>
      <link>/post/2021-05-11-telegrambot/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021-05-11-telegrambot/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;申请telegram-bot&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;申请telegram bot&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在telegram中搜索“BotFather”，进入与其聊天页面&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;/start&lt;/code&gt;查看可用选项&lt;/li&gt;
&lt;li&gt;输入或点击&lt;code&gt;/newbot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入bot的名字（必须以&lt;code&gt;Bot&lt;/code&gt;或&lt;code&gt;_bot&lt;/code&gt;结尾）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成后收到如下消息，点击&lt;code&gt;t.me/xxxxxx_bot&lt;/code&gt;即可进入与bot聊天页面&lt;/p&gt;
&lt;p&gt;Done! Congratulations on your new bot. You will find it at &lt;code&gt;t.me/xxxxxx_bot&lt;/code&gt;. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you’ve finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.&lt;/p&gt;
&lt;p&gt;Use this token to access the HTTP API:
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Keep your token secure and store it safely, it can be used by anyone to control your bot.&lt;/p&gt;
&lt;p&gt;For a description of the Bot API, see this page: &lt;a href=&#34;https://core.telegram.org/bots/api&#34; class=&#34;uri&#34;&gt;https://core.telegram.org/bots/api&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;使用curl发送消息&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;使用cURL发送消息&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在与bot聊天页面输入任意消息&lt;/li&gt;
&lt;li&gt;打开https://api.telegram.org/bot&lt;code&gt;{TOKEN}&lt;/code&gt;/getUpdates （这里有这个bot的消息历史）&lt;/li&gt;
&lt;li&gt;在这个JSON文件中找到&lt;code&gt;CHAT_ID&lt;/code&gt; (…“chat”:{“id”:{CHAT_ID}…)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来使用如下命令发送消息（TOKEN和CHAT_ID替换为自己的），好像群组的chat ID为负数，个人的chat ID为正数&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;TELEGRAM_BOT_TOKEN=TOKEN
curl -X POST \
     -H &amp;#39;Content-Type: application/json&amp;#39; \
     -d &amp;#39;{&amp;quot;chat_id&amp;quot;: &amp;quot;CHAT_ID&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;测试消息！&amp;quot;}&amp;#39;
     &amp;quot;https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到如下提示，并收到telegram消息&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;{&amp;quot;ok&amp;quot;:true,&amp;quot;result&amp;quot;:{&amp;quot;message_id&amp;quot;:14,&amp;quot;from&amp;quot;:{&amp;quot;id&amp;quot;:BOT_ID,&amp;quot;is_bot&amp;quot;:true,&amp;quot;first_name&amp;quot;:&amp;quot;xxxxxxx_bot&amp;quot;,&amp;quot;username&amp;quot;:&amp;quot;xxxxxxxx_bot&amp;quot;},&amp;quot;chat&amp;quot;:{&amp;quot;id&amp;quot;:CHAT_ID,&amp;quot;first_name&amp;quot;:&amp;quot;XXXX&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;private&amp;quot;},&amp;quot;date&amp;quot;:1620736546,&amp;quot;text&amp;quot;:&amp;quot;测试消息！&amp;quot;}}%&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;参考&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/telegram-push-notifications-58477e71b2c2/&#34; class=&#34;uri&#34;&gt;https://www.freecodecamp.org/news/telegram-push-notifications-58477e71b2c2/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>BEEM-Static: Accurate inference of ecological interactions from cross-sectional metagenomic data</title>
      <link>/publication/biorxiv_beemstatic/</link>
      <pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>/publication/biorxiv_beemstatic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atopic Dermatitis Microbiomes Stratify into Ecologic Dermotypes Enabling Microbial Virulence and Disease Severity</title>
      <link>/publication/jaci_skin/</link>
      <pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>/publication/jaci_skin/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Kraken拓展工具KrakenTools</title>
      <link>/post/2020-08-22-krakentools/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020-08-22-krakentools/</guid>
      <description>&lt;div id=&#34;背景&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;Kraken（Kraken2）默认的report格式并不利于后续的分析，在运行Kraken时我通常会使用&lt;code&gt;--use-mpa-style&lt;/code&gt;这个参数来生成像MetaPhlan（MetaPhlan2）格式的结果。但是如果想要做后续的分析（Bracken），就还要用到report格式的结果。之前我采用的策略是&lt;a href=&#34;https://lichenhao.netlify.app/post/2019-10-17-nextflow-kraken/&#34;&gt;运行两次Kraken2&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;### run it twice...
kraken2 \
    --db $KRAKEN_DB \
    --paired \
    --threads 8 \
    --output ${prefix}.out \
    --report ${prefix}.kraken2.tsv \
    $fq1 $fq2 \
    --use-mpa-style

### run again for bracken
kraken2 \
    --db $KRAKEN_DB \
    --paired \
    --threads 8 \
    --report ${prefix}.kraken2 \
    $fq1 $fq2 &amp;gt; /dev/null&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经验上来讲Kraken很大一部分运行时间花在将数据库载入内存和硬盘读写（IO），对于大数据库、深度测序，会造成一定的资源浪费、并且CPU利用率不高。&lt;/p&gt;
&lt;p&gt;最近发现了Bracken的作者开发的&lt;a href=&#34;https://github.com/jenniferlu717/KrakenTools&#34;&gt;很有用的工具集&lt;/a&gt;。其中包含一个将Kraken report格式转换为mpa格式的输出的脚本&lt;code&gt;kreport2mpa.py&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;使用kreport2mpa.py简化kraken流程&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;使用&lt;code&gt;kreport2mpa.py&lt;/code&gt;简化kraken流程&lt;/h2&gt;
&lt;p&gt;下面是简化后的Kraken2流程：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;kraken2 \
    --db $KRAKEN_DB \
    --paired \
    --threads 8 \
    --output ${prefix}.kraken2.out \
    --report ${prefix}.kraken2.report \
    $reads1 $reads2 
    ### Convert kraken report to mpa file
kreport2mpa.py \
     -r ${prefix}.kraken2.report \
     -o ${prefix}.kraken2.tax \
     --no-intermediate-ranks&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;shotgunmetagenomics-nf流程的develop branch已经更新了对应的&lt;a href=&#34;https://github.com/lch14forever/shotgunmetagenomics-nf/blob/develop/modules/profilers_kraken2_bracken.nf&#34;&gt;module&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;使用extract_kraken_reads.py提取对应taxid的序列&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;使用&lt;code&gt;extract_kraken_reads.py&lt;/code&gt;提取对应TaxID的序列&lt;/h2&gt;
&lt;p&gt;这个程序可以用来快速过滤出属于一个物种（或其他分类等级）的序列。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;## 提取E. coli序列
extract_kraken_reads.py \
    -t 562 \ 
    -k ${prefix}.kraken2.report \
    -s1 $reads1 -s2 $reads2 \
    -o $extracted1 -o2 $extracted2 \
    --fastq-output&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;参考&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;KrakenTools: &lt;a href=&#34;https://github.com/jenniferlu717/KrakenTools&#34; class=&#34;uri&#34;&gt;https://github.com/jenniferlu717/KrakenTools&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Cartography of opportunistic pathogens and antibiotic resistance genes in a tertiary hospital environment</title>
      <link>/publication/naturemedicine_hospital/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/publication/naturemedicine_hospital/</guid>
      <description></description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-VI Nextflow tower本地配置</title>
      <link>/post/2019-10-29-nextflow-tower-deploy/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-10-29-nextflow-tower-deploy/</guid>
      <description>&lt;div id=&#34;测试环境&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;测试环境&lt;/h3&gt;
&lt;p&gt;Ubuntu 18.04 （Root权限）&lt;/p&gt;
&lt;p&gt;AWS安全组配置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Custom TCP&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;8000&lt;/th&gt;
&lt;th&gt;0.0.0.0/0&lt;/th&gt;
&lt;th&gt;ss&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Custom TCP&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;8000&lt;/td&gt;
&lt;td&gt;::/0&lt;/td&gt;
&lt;td&gt;ss&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;安装jdk1.8及编译依赖&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;安装jdk（&amp;gt;1.8）及编译依赖&lt;/h3&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;sudo apt update
sudo apt install openjdk-8-jdk-headless
sudo apt install build-essential&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;安装dockerdocker-compose&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;安装docker，docker-compose&lt;/h3&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;sudo apt install docker.io
sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;更改docker权限此处需要登出并重新登陆&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;更改docker权限（此处需要登出并重新登陆）&lt;/h3&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;sudo usermod -a -G docker $USER&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;下载nf-tower&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;下载nf-tower&lt;/h3&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;## install git
sudo apt install git
git clone https://github.com/seqeralabs/nf-tower&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;配置环境变量&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;此处需要申请一个发邮件的服务器，nf推荐了https://sendgrid.com&lt;/p&gt;
&lt;p&gt;在左侧选项栏点击&lt;code&gt;Settings&lt;/code&gt;–&amp;gt;&lt;code&gt;APIKeys&lt;/code&gt;–&amp;gt;&lt;code&gt;Create API Key&lt;/code&gt;–&amp;gt;输入key name并选择Full Access
点击生成的秘钥直接拷贝到剪切板，如“SG.dsVDEPp9SCOJFxe8QObVcAxxxxxxxxxxxxx”&lt;/p&gt;
&lt;p&gt;编辑配置文件&lt;code&gt;nf-tower/tower-backend/src/main/resources/application.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;...
  smtp:
    host: &amp;quot;smtp.sendgrid.net&amp;quot;
    port: &amp;quot;587&amp;quot;
    auth: &amp;quot;${TOWER_SMTP_AUTH:true}&amp;quot;
    user: &amp;quot;apikey&amp;quot;
    password: &amp;quot;SG.dsVDEPp9SCOJFxe8QObVcAxxxxxxxxxxxxx&amp;quot;
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;编译tower&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;编译tower&lt;/h3&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;make build
make run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;使用nextflow-tower&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;使用Nextflow Tower&lt;/h3&gt;
&lt;p&gt;使用方法基本与tower.nf网站一致。有一点需要注意，如果nextflow部署在服务器上，需要修改邮件中的链接地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件中链接为：&lt;a href=&#34;http://&#34; class=&#34;uri&#34;&gt;http://&lt;/a&gt;&lt;strong&gt;localhost&lt;/strong&gt;:8000/auth?uid=xxxx&lt;/li&gt;
&lt;li&gt;修改为：&lt;a href=&#34;http://&#34; class=&#34;uri&#34;&gt;http://&lt;/a&gt;&lt;strong&gt;服务器地址&lt;/strong&gt;:8000/auth?uid=xxxx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-V Nextflow tower</title>
      <link>/post/2019-10-25-nextflow-tower/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-10-25-nextflow-tower/</guid>
      <description>&lt;p&gt;登录Nextflow Tower的&lt;a href=&#34;tower.nf&#34;&gt;官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“Sign in”并输入邮箱，会在邮箱中收到登录链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;nextflow-login.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;登陆后看到如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;nextflow-token.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在运行nextflow前设置环境变量&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ export TOWER_ACCESS_TOKEN=xxxxxxxxxxxxxxxxxxxxxxx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在运行上一篇的流程时，加入&lt;code&gt;-with-tower&lt;/code&gt;参数&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ./main.nf --read_path data -with-tower

N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [angry_venter] - revision: 72dddbcd1f
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
Monitor the execution with Nextflow Tower using this url https://tower.nf/watch/xxxxxx
executor &amp;gt;  local (8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用上面的链接或登录Nextflow Tower便可实时监控流程的运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;nextflow-tower.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;运行完成后可以查看流程使用资源的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;nextflow-finish.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;(未完)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-IV Kraken2&#43;Bracken</title>
      <link>/post/2019-10-17-nextflow-kraken/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-10-17-nextflow-kraken/</guid>
      <description>&lt;div id=&#34;shell&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Shell脚本&lt;/h2&gt;
&lt;p&gt;和fastp+decont的步骤一样，我们可以首先将流程写成一个shell脚本：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/bash
set -e -o pipefail
source activate metagenomics

fq1=$1
fq2=$2
prefix=$3
KRAKEN_DB=/data/minikraken2_v2_8GB 

### run it twice...
kraken2 \
    --db $KRAKEN_DB \
    --paired \
    --threads 8 \
    --output ${prefix}.out \
    --report ${prefix}.kraken2.tsv \
    $fq1 $fq2 \
    --use-mpa-style

### run again for bracken
kraken2 \
    --db $KRAKEN_DB \
    --paired \
    --threads 8 \
    --report ${prefix}.kraken2 \
    $fq1 $fq2 &amp;gt; /dev/null


for tax in s g;
do
bracken -d ${KRAKEN_DB} \
    -i ${prefix}.kraken2 \
    -o ${prefix}.bracken.${tax} \
    -l ${tax^^}

sed &amp;#39;s/ /_/g&amp;#39; ${prefix}.bracken.${tax} | \
    tail -n+2 | \
    cut -f 1,7 &amp;gt; ${prefix}.${tax}
done&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的脚本里面，为了获取mpa（MetaPhlAn）格式的输出，我运行了两次Kraken2，第一次生成mpa格式的分类谱，第二次生成Bracken所需要的report格式。Kraken2的参考数据库（含Bracken参考）可从官方&lt;a href=&#34;https://ccb.jhu.edu/software/kraken2/downloads.shtml&#34;&gt;FTP&lt;/a&gt;下载。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;nextflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Nextflow模块&lt;/h2&gt;
&lt;p&gt;将上面的脚本写成一个nextflow模块kraken2.nf：&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;params.outdir = &amp;#39;./&amp;#39;

process KRAKEN2 {
    tag &amp;quot;${prefix}&amp;quot;
    cpus 8
    publishDir params.outdir, mode: &amp;#39;copy&amp;#39;

    input:
    file index_path
    tuple prefix, file(reads1), file(reads2)

    output:
    tuple prefix, file(&amp;quot;${prefix}.kraken2.report&amp;quot;)
    tuple prefix, file(&amp;quot;${prefix}.kraken2.tax&amp;quot;)
    file &amp;quot;${prefix}.kraken2.out&amp;quot;

    script:
    &amp;quot;&amp;quot;&amp;quot;
    kraken2 \\
    --db $index_path \\
    --paired \\
    --threads $task.cpus \\
    --output ${prefix}.kraken2.out \\
    --report ${prefix}.kraken2.tax \\
    $reads1 $reads2 \\
    --use-mpa-style \\

    ### run again for bracken
    kraken2 \\
    --db $index_path \\
    --paired \\
    --threads $task.cpu \\
    --report ${prefix}.kraken2.report \\
    $reads1 $reads2 \\
    --output -
    &amp;quot;&amp;quot;&amp;quot;
}

process BRACKEN {
    tag &amp;quot;${prefix}&amp;quot;
    publishDir params.outdir, mode: &amp;#39;copy&amp;#39;

    input:
    file index_path  // This must have the bracken database
    tuple prefix, file(kraken2_report)
    each tax

    output:
    file &amp;quot;${prefix}*.tsv&amp;quot;

    script:
    &amp;quot;&amp;quot;&amp;quot;
    TAX=$tax; \\

    bracken -d $index_path \\
    -i $kraken2_report \\
    -o ${prefix}.bracken.${tax} \\
    -l \${TAX^^}; \\

    sed &amp;#39;s/ /_/g&amp;#39; ${prefix}.bracken.${tax} | \\
    tail -n+2 | \\
    cut -f 1,7 &amp;gt; ${prefix}.bracken.${tax}.tsv
    &amp;quot;&amp;quot;&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;each&lt;/code&gt;相当于上面脚本的&lt;code&gt;for&lt;/code&gt;循环，对于不同的分类&lt;code&gt;s&lt;/code&gt;（species），&lt;code&gt;g&lt;/code&gt;（genus）分别运行bracken。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;主脚本中调用模块&lt;/h2&gt;
&lt;p&gt;接上一篇中的主脚本（&lt;code&gt;main.nf&lt;/code&gt;），我们可以直接使用DECONT过程的结果作为Kraken2+Bracken的输入：&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow

// DSL 2 syntax
nextflow.preview.dsl=2

// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;

// parameters decont
params.decont_refpath = &amp;#39;/data/nucleotide/&amp;#39;
params.decont_index   = &amp;#39;hg19.fa&amp;#39;
params.decont_outdir  = &amp;#39;./pipeline_output/decont_out&amp;#39;
ch_bwa_idx = file(params.decont_refpath)
// parameters kraken2                                              // ***
params.kraken2_refpath = &amp;#39;/data/minikraken2_v2_8GB_201904_UPDATE/&amp;#39; // ***
params.kraken2_outdir = &amp;#39;./pipeline_output/kraken2_out&amp;#39;            // ***
ch_kraken_idx = file(params.kraken2_refpath)                       // ***

include &amp;#39;./decont&amp;#39; params(index: &amp;quot;$params.decont_index&amp;quot;, outdir: &amp;quot;$params.decont_outdir&amp;quot;)
include &amp;#39;./kraken2&amp;#39; params(outdir: &amp;quot;$params.kraken2_outdir&amp;quot;)       // ***


// help message
def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}

// Create channel for reads
ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

workflow{
    DECONT(ch_bwa_idx, ch_reads)
    KRAKEN2(ch_kraken_idx, DECONT.out[0])                          // ***
    BRACKEN(ch_kraken_idx, KRAKEN2.out[0], Channel.from(&amp;#39;s&amp;#39;, &amp;#39;g&amp;#39;)) // ***
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入&lt;code&gt;// ***&lt;/code&gt;的部分为添加的内容&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;逐行解析&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;配置参数&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;// parameters kraken2                                              // ***
params.kraken2_refpath = &amp;#39;/data/minikraken2_v2_8GB_201904_UPDATE/&amp;#39; // ***
params.kraken2_outdir = &amp;#39;./pipeline_output/kraken2_out&amp;#39;            // ***
ch_kraken_idx = file(params.kraken2_refpath)                       // ***&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处于DECONT过程的配置类似，这里假设Bracken的索引和Kraken2的索引在同一个目录下。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;引用模块&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;include &amp;#39;./kraken2&amp;#39; params(outdir: &amp;quot;$params.kraken2_outdir&amp;quot;)      // ***&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处与DECONT过程的配置类似&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;流程定义&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;workflow{
    DECONT(ch_bwa_idx, ch_reads)
    KRAKEN2(ch_kraken_idx, DECONT.out[0])                          // ***
    BRACKEN(ch_kraken_idx, KRAKEN2.out[0], Channel.from(&amp;#39;s&amp;#39;, &amp;#39;g&amp;#39;)) // ***
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上一篇博文，DECONT的输出被定义为两个tuple：&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;output:
    tuple prefix, file(&amp;quot;${prefix}*1.fastq.gz&amp;quot;), file(&amp;quot;${prefix}*2.fastq.gz&amp;quot;)
    tuple file(&amp;quot;${prefix}.html&amp;quot;), file(&amp;quot;${prefix}.json&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一个tuple为去宿主DNA之后的fastq文件，第二个为fastp的质控文件，运行KRAKEN过程的时候，我们以&lt;code&gt;DECONT.out[0]&lt;/code&gt;来使用DECONT过程结果的第一个tuple。同样的，在BRACKEN过程调用时，我们以&lt;code&gt;KRAKEN2.out[0]&lt;/code&gt;来使用KRAKEN2过程结果的第一个tuple&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;执行&lt;/h2&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls data
$ ./main.nf
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [jolly_heyrovsky] - revision: b913fda572
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
executor &amp;gt;  local (8)
[6f/7c66ef] process &amp;gt; DECONT (SRR1950773)  [100%] 2 of 2 ✔
[51/9f4f92] process &amp;gt; KRAKEN2 (SRR1950773) [100%] 2 of 2 ✔
[c7/603e5e] process &amp;gt; BRACKEN (SRR1950772) [100%] 4 of 4 ✔
Completed at: 17-Oct-2019 12:57:14
Duration    : 3m 50s
CPU hours   : 0.5
Succeeded   : 8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls pipeline_output/kraken2_out/
SRR1950772.bracken.g.tsv  SRR1950772.kraken2.out     SRR1950772.kraken2.tax    SRR1950773.bracken.s.tsv  SRR1950773.kraken2.report
SRR1950772.bracken.s.tsv  SRR1950772.kraken2.report  SRR1950773.bracken.g.tsv  SRR1950773.kraken2.out    SRR1950773.kraken2.tax&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://www.nextflow.io/docs/latest/&#34; class=&#34;uri&#34;&gt;https://www.nextflow.io/docs/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-III 质控&#43;去宿主DNA</title>
      <link>/post/2019-10-01-nextflow-decont/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-10-01-nextflow-decont/</guid>
      <description>&lt;div id=&#34;shell&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Shell脚本&lt;/h2&gt;
&lt;p&gt;质控和去宿主主要由以下工具完成：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;fastp: 去接头，修剪低质量序列&lt;/li&gt;
&lt;li&gt;BWA + samtools：去宿主&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参照这篇&lt;a href=&#34;http://www.metagenomics.wiki/tools/short-read/remove-host-sequences&#34;&gt;教程&lt;/a&gt;，我们可以设计如下简单的流程：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/bash

## requirement:
## fastp, BWA, samtools &amp;gt;= 1.7

ref=$1
reads1=$2
reads2=$3
prefix=$4
threads=${5:-4}

fastp -i $reads1 -I $reads2 --stdout -j ${prefix}.json -h ${prefix}.html | 
    bwa mem -p -t $threads $ref - | 
    samtools fastq -f12 -F256  -1  ${prefix}_fastpdecont_1.fastq.gz -2 ${prefix}_fastpdecont_2.fastq.gz -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处尽可能地使用管道来避免硬盘读写和不必要的数据存储。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;nextflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Nextflow模块&lt;/h2&gt;
&lt;p&gt;我们可以把以上脚本写成简单的nextflow模块decont.nf：&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;params.index = &amp;#39;hg19.fa&amp;#39;
params.outdir = &amp;#39;./&amp;#39;

process DECONT {
    tag &amp;quot;${prefix}&amp;quot;
    cpus 8
    publishDir params.outdir, mode: &amp;#39;copy&amp;#39;

    input:
    file index_path
    tuple prefix, file(reads1), file(reads2)

    output:
    tuple prefix, file(&amp;quot;${prefix}*1.fastq.gz&amp;quot;), file(&amp;quot;${prefix}*2.fastq.gz&amp;quot;)
    tuple file(&amp;quot;${prefix}.html&amp;quot;), file(&amp;quot;${prefix}.json&amp;quot;)

    script:
    &amp;quot;&amp;quot;&amp;quot;
    fastp -i $reads1 -I $reads2 --stdout -j ${prefix}.json -h ${prefix}.html | \\
    bwa mem -p -t $task.cpus ${index_path}/${params.index} - | \\
    samtools fastq -f12 -F256  -1  ${prefix}_fastpdecont_1.fastq.gz -2 ${prefix}_fastpdecont_2.fastq.gz -
    &amp;quot;&amp;quot;&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;逐行解析&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;模块参数:&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;params.index = &amp;#39;hg19.fa&amp;#39;
params.outdir = &amp;#39;./&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和上一篇介绍的流程参数一致，定义了在该模块的参数（我推测这些参数的scope是local，即仅限于该模块，有待确定）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;过程定义：&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;process DECONT {
    input:
    ...
    output:
    ...
    script:
    ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上为Nextflow过程(process)的骨架结构，主要由输入(input)，输出(output)，脚本(script)来构成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;过程指令：&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;tag &amp;quot;${prefix}&amp;quot;
cpus 8
publishDir params.outdir, mode: &amp;#39;copy&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tag&lt;/code&gt;：给每一个过程执行命名，方便在执行日志中查看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpus&lt;/code&gt;：此过程运行时的CPU数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;publishDir&lt;/code&gt;：结果发布路径，运行完成后将最终的结果（由&lt;code&gt;output&lt;/code&gt;定义）拷贝（&lt;code&gt;&#39;copy&#39;&lt;/code&gt;）到该路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的指令建议参考Nextflow的&lt;a href=&#34;https://www.nextflow.io/docs/latest/process.html#directives&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;输入、输出：&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;input:
    file index_path
    tuple prefix, file(reads1), file(reads2)

output:
    tuple prefix, file(&amp;quot;${prefix}*1.fastq.gz&amp;quot;), file(&amp;quot;${prefix}*2.fastq.gz&amp;quot;)
    tuple file(&amp;quot;${prefix}.html&amp;quot;), file(&amp;quot;${prefix}.json&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由关键字&lt;code&gt;input:&lt;/code&gt;或&lt;code&gt;output:&lt;/code&gt;(注意冒号)构成，后面接内容(全都为&lt;code&gt;Channel&lt;/code&gt;类型)。内容可包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值(&lt;code&gt;val&lt;/code&gt;)：可省略&lt;/li&gt;
&lt;li&gt;文件(&lt;code&gt;file&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;列表(&lt;code&gt;tuple&lt;/code&gt;)：形式为&lt;code&gt;[element1, element2, elemnet3, ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：似乎在Nextflow文档中&lt;code&gt;tuple&lt;/code&gt;和&lt;code&gt;list&lt;/code&gt;等同。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;脚本&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;script:
    &amp;quot;&amp;quot;&amp;quot;
    fastp -i $reads1 -I $reads2 --stdout -j ${prefix}.json -h ${prefix}.html | \\
    bwa mem -p -t $task.cpus ${index_path}/${params.index} - | \\
    samtools fastq -f12 -F256  -1  ${prefix}_fastpdecont_1.fastq.gz -2 ${prefix}_fastpdecont_2.fastq.gz -
    &amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nextflow过程的脚本部分为Shell脚本，注意Shell中变量要使用&lt;code&gt;\$&lt;/code&gt;开头。脚本部分涉及的文件(或路径)必须是Channel。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;在主脚本中调用模块&lt;/h2&gt;
&lt;p&gt;延续上一篇中的主脚本(&lt;code&gt;main.nf&lt;/code&gt;)，我们可以调用DECONT过程：&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow

// DSL 2 syntax
nextflow.preview.dsl=2

// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;

// parameters decont                                                                       // ***
params.decont_refpath = &amp;#39;/data/nucleotide/&amp;#39;                                                // ***
params.decont_index   = &amp;#39;hg19.fa&amp;#39;                                                          // ***
params.decont_outdir  = &amp;#39;./pipeline_output/decont_out&amp;#39;                                     // ***
ch_bwa_idx = file(params.decont_refpath)                                                   // ***
include &amp;#39;./decont&amp;#39; params(index: &amp;quot;$params.decont_index&amp;quot;, outdir: &amp;quot;$params.decont_outdir&amp;quot;)  // ***


// help message
def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}

// Create channel for reads
ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

workflow{                                                                                 // ***
    DECONT(ch_bwa_idx, ch_reads)                                                          // ***
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入&lt;code&gt;// ***&lt;/code&gt;的部分为添加的内容&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;逐行解析&lt;/h2&gt;
&lt;div id=&#34;decont&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;配置DECONT过程参数&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;// parameters decont                                                                       // ***
params.decont_refpath = &amp;#39;/data/nucleotide/&amp;#39;                                                // ***
params.decont_index   = &amp;#39;hg19.fa&amp;#39;                                                          // ***
params.decont_outdir  = &amp;#39;./pipeline_output/decont_out&amp;#39;                                     // ***
ch_bwa_idx = file(params.decont_refpath)                                                   // ***&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们知道DECONT部分需要四个参数：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;BWA索引路径&lt;/li&gt;
&lt;li&gt;BWA索引的前缀&lt;/li&gt;
&lt;li&gt;DECONT输出路径&lt;/li&gt;
&lt;li&gt;输入fastq文件：[prefix, r1.fastq, r2.fastq] (&lt;code&gt;tuple prefix, file(reads1), file(reads2)&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意这里BWA索引路径需要以Channel的形式传入&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;引用模块&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;include &amp;#39;./decont&amp;#39; params(index: &amp;quot;$params.decont_index&amp;quot;, outdir: &amp;quot;$params.decont_outdir&amp;quot;)  // ***&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非文件或路径的参数通过&lt;code&gt;params(param1:, param2:)&lt;/code&gt;传入。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;流程定义&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;workflow{                                                                                 // ***
    DECONT(ch_bwa_idx, ch_reads)                                                          // ***
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行流程，process所需的输入文件通过上面的方式传入。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;执行&lt;/h2&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls data
SRR1950772_1.fastq.gz  SRR1950772_2.fastq.gz  SRR1950773_1.fastq.gz  SRR1950773_2.fastq.gz
$ ./main.nf
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [desperate_mcnulty] - revision: f74174c1c6
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
executor &amp;gt;  local (2)
[f7/14223b] process &amp;gt; DECONT (SRR1950773) [100%] 2 of 2 ✔&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls pipeline_output/decont_out/
SRR1950772_fastpdecont_1.fastq.gz  SRR1950772.html  SRR1950773_fastpdecont_1.fastq.gz  SRR1950773.html
SRR1950772_fastpdecont_2.fastq.gz  SRR1950772.json  SRR1950773_fastpdecont_2.fastq.gz  SRR1950773.json&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://www.nextflow.io/docs/latest/&#34; class=&#34;uri&#34;&gt;https://www.nextflow.io/docs/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-II 主函数和输入输出</title>
      <link>/post/2019-09-29-nextflow-main/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-09-29-nextflow-main/</guid>
      <description>&lt;div id=&#34;nextflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;第一个Nextflow程序&lt;/h2&gt;
&lt;p&gt;创建以下名为main.nf的Nextflow文件&lt;/p&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow

// DSL 2 syntax
nextflow.preview.dsl=2

// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;

// help message
def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}

// Create channel for reads
ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

ch_reads.view()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;逐行解析&lt;/h2&gt;
&lt;div id=&#34;shebang&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Shebang&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;#!/usr/bin/env nextflow&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同很多Unix-like脚本一样，第一行叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_(Unix)&#34;&gt;“shebang” (Hash bang)&lt;/a&gt;，出现在脚本第一行并以&lt;code&gt;#!&lt;/code&gt;开头。它告诉系统用什么环境软件去解析这个脚本，当它存在并且脚本可执行的时候，我们可以通过直接调用该脚本来运行程序。以下为示例：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;通过Interpreter来调用脚本（shebang不存在时也可使用）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;nextflow run ./main.nf&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;直接调用（需要shebang）：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;chmod u+x ./main.nf ## 添加可执行权限
./main.nf           ## 系统自动使用nextflow运行&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dsl2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;使用DSL2语言&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;nextflow.preview.dsl=2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：DSL2是新功能，后续语法可能会调整&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;流程参数&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;// parameters
params.help = false
params.read_path  = &amp;quot;${workflow.projectDir}/data&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nextflow通过params这个字典来允许执行时直接传入参数。上述的两个参数&lt;code&gt;help&lt;/code&gt;，和&lt;code&gt;read_path&lt;/code&gt;，在命令行中可通过&lt;code&gt;--help&lt;/code&gt;，&lt;code&gt;--read_path /PATH/TO/READS&lt;/code&gt;，来更改。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;./main.nf --help ## 将params.help的值更改为true
./main.nf --read_path /data/reads/ ## 将params.read_path的值更改为~/reads&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;groovy&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Groovy原生支持&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;def helpMessage() {
    log.info&amp;quot;&amp;quot;&amp;quot;
    =================================================================
    Usage: ${workflow.projectDir}/main.nf --read_path PATH/OF/READS
    =================================================================
    &amp;quot;&amp;quot;&amp;quot;.stripIndent()
}
if (params.help){
    helpMessage()
    exit 0
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nextflow基于Groovy语言，可在流程中直接使用。以上部分定义了函数&lt;code&gt;helppMessage&lt;/code&gt;，在接到&lt;code&gt;--help&lt;/code&gt;输入时会输出帮助文档并退出执行。&lt;code&gt;workflow&lt;/code&gt;为Nextflow定义的特殊字典，&lt;code&gt;${workflow.projectDir}&lt;/code&gt;对应了当前脚本(&lt;code&gt;main.nf&lt;/code&gt;)的目录。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ./main.nf --help
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [distraught_meitner] - revision: bb88634790
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
=================================================================
Usage: /home/ubuntu/shotgunmetagenomics-nf/tutorial/main.nf --read_path PATH/OF/READS
=================================================================&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;channel&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Channel&lt;/h3&gt;
&lt;pre class=&#34;groovy&#34;&gt;&lt;code&gt;ch_reads = Channel
    .fromFilePairs(params.read_path + &amp;#39;/**{1,2}.f*q*&amp;#39;, flat: true)

ch_reads.view()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Netflow定义了Channel，通过Channel来在不同过程(Process)之间传递文件。Channel保证了基于不同文件的运算独立、并行进行。Channel对应的文件会被“拷贝”(经常以symbolic link的形式)到&lt;code&gt;work/&lt;/code&gt;目录下。这个定义其实不是很容易说得清楚，建议阅读Nextflow&lt;a href=&#34;https://www.nextflow.io/docs/latest/channel.html&#34;&gt;帮助文档&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fromFilePair&lt;/code&gt;专门为fastq打造，可以直接将不同的样本以列表形式分组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;/**{1,2}.f*q*&#39;&lt;/code&gt;定义了文件匹配方式，&lt;code&gt;**&lt;/code&gt;表示递归地检索文件，&lt;code&gt;{1,2}.f*q*&lt;/code&gt;跟bash本身的文件匹配一致，这里会匹配结尾为&lt;code&gt;1.fastq.gz&lt;/code&gt;，&lt;code&gt;2.fastq&lt;/code&gt;，&lt;code&gt;1.fq&lt;/code&gt;，&lt;code&gt;2.fq.gz&lt;/code&gt;的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flat: ture&lt;/code&gt;使返回的双端序列和匹配ID存储为一个列表中。下面是一个例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;$ ls /data/reads/
SRR1950772_1.fastq.gz  SRR1950772_2.fastq.gz  SRR1950773_1.fastq.gz  SRR1950773_2.fastq.gz

$ ./main.nf --read_path /data/reads/
N E X T F L O W  ~  version 19.09.0-edge
Launching `./main.nf` [elegant_volta] - revision: bb88634790
WARN: DSL 2 IS AN EXPERIMENTAL FEATURE UNDER DEVELOPMENT -- SYNTAX MAY CHANGE IN FUTURE RELEASE
[SRR1950773, /data/reads/SRR1950773_1.fastq.gz, /data/reads/SRR1950773_2.fastq.gz]
[SRR1950772, /data/reads/SRR1950772_1.fastq.gz, /data/reads/SRR1950772_2.fastq.gz]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果默认情况 (&lt;code&gt;flat: false&lt;/code&gt;)使用&lt;code&gt;.fromFilePairs(params.read_path + &#39;/**{1,2}.f*q*&#39;)&lt;/code&gt;，输出结果会将Read1和Read2合并在一个列表中：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;[SRR1950773, [/data/reads/SRR1950773_1.fastq.gz, /data/reads/SRR1950773_2.fastq.gz]]
[SRR1950772, [/data/reads/SRR1950772_1.fastq.gz, /data/reads/SRR1950772_2.fastq.gz]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://www.nextflow.io/docs/latest/&#34; class=&#34;uri&#34;&gt;https://www.nextflow.io/docs/latest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>基于Nextflow的宏基因组有参分析-I 安装Nextflow</title>
      <link>/post/2019-09-27-nextflow-install/</link>
      <pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-09-27-nextflow-install/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;开一个坑&lt;/h2&gt;
&lt;p&gt;本系列介绍如何搭建基于Nextflow的宏基因组有参分析流程。在此之前我曾经使用bpipe和snakemake写过这个&lt;a href=&#34;https://github.com/lch14forever/shotgun-metagenomics-pipeline&#34;&gt;流程&lt;/a&gt;。在我们实验室中所有的有参分析都是这个pipeline跑出来的。个人感觉bpipe用起来其实很顺手自然，但是由于社区实在是不够活跃。snakemake基于python而且有很多开发者支持，所以为了学习snakemake，我将之前的流程重新写成了snakemake。但是后来渐渐发现make的这种从后向前结构很别扭，基于文件名构建DAG也是缺乏灵活性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nextflow.io/&#34;&gt;Nextflow&lt;/a&gt;作为后起之秀迅速成长，拥有很好的社区支持（&lt;a href=&#34;https://groups.google.com/forum/#!forum/nextflow&#34;&gt;google group&lt;/a&gt;，&lt;a href=&#34;https://gitter.im/nextflow-io/nextflow&#34;&gt;gitter&lt;/a&gt;），原生对云环境（AWS，google cloud）支持，拥有大量优秀成熟流程&lt;a href=&#34;https://github.com/nf-core&#34;&gt;nf-core&lt;/a&gt;。最近的一次更新推出了模块化的&lt;a href=&#34;https://www.nextflow.io/blog/2019/one-more-step-towards-modules.html&#34;&gt;DSL 2架构&lt;/a&gt;，构建可重复利用的流程未来可期。为了更好地学习Nextflow，我将把之前的shotgunMetagenomics流程重写，并把过程记录下来，也希望可以帮助到更多人。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;流程介绍&lt;/h2&gt;
&lt;p&gt;这个流程可以参见snakemake生成的DAG:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/lch14forever/shotgun-metagenomics-pipeline/raw/master/snakemake_pipeline/work_flow.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;步骤为：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;合并相同样本&lt;/li&gt;
&lt;li&gt;去接头&lt;/li&gt;
&lt;li&gt;去宿主DNA&lt;/li&gt;
&lt;li&gt;使用Profiling工具（kraken2，MetaPhlAn2）&lt;/li&gt;
&lt;li&gt;按系统分类拆分&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;## 安装Nextflow&lt;/p&gt;
&lt;p&gt;依赖：java &amp;gt;= 1.8&lt;/p&gt;
&lt;p&gt;稳定版本安装：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;curl -s https://get.nextflow.io | bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Github开发版本安装，支持DSL2语法：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;git clone https://github.com/nextflow-io/nextflow.git

cd nextflow

make compile

make pack&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的Nextflow在&lt;code&gt;build/releases/nextflow-19.09.0-edge-all&lt;/code&gt;，可以重新命名为&lt;code&gt;nextflow&lt;/code&gt;并放在&lt;code&gt;$PATH&lt;/code&gt;中。&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;export PATH=$PATH:/PATH/TO/REPO/build/releases/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(未完)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An expectation-maximization algorithm enables accurate ecological modeling using longitudinal metagenome sequencing data</title>
      <link>/publication/microbiome_beem/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/publication/microbiome_beem/</guid>
      <description></description>
    </item>
    
    <item>
      <title>启动Conda环境时自动更改环境变量</title>
      <link>/post/2019-08-17-conda-activate/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-17-conda-activate/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;这是一个神奇的路径&lt;/h2&gt;
&lt;p&gt;我们在服务器上用conda创建了一个叫&lt;code&gt;metagenomics&lt;/code&gt;的环境，希望将常用分析软件安装在该环境。其中一些软件需要使用新版本的gcc编译（如：kraken2）。安装的准备套路应该如下：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;export PATH=/opt/gcc-4.9.3/bin/:$PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64/:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如果我希望以上环境变量仅对我特定的Conda环境起效（&lt;code&gt;metagenomics&lt;/code&gt;）应该怎么办呢？我们需要像.bashrc (.bash_profile)和.bash_logout这样在环境activate和deactivate时自动执行的脚本。在Conda中，我们需要如下目录：&lt;/p&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;ANACONDA_PATH/envs/ENV_PATH/etc/conda/
├── activate.d        
│   └── env_vars.sh   ## &amp;lt;- sourced when you do `conda activate`
└── deactivate.d     
    └── env_vars.sh   ## &amp;lt;- sourced when you do `conda deactivate`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;剩下的就是shell脚本的编写了，在下面的例子中，我们创建了一个叫做metagenomics的环境，并在其中安装了metaphlan2，kraken2，strainphlan。&lt;/p&gt;
&lt;div id=&#34;activate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;activate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

## CANU
export OLD_PATH=$PATH
export PATH=$(echo $PATH | sed &amp;#39;s;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:;/mnt/software/unstowable/anaconda/envs/metagenomics/bin:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/utils/:/mnt/software/unstowable/biobakery-metaphlan2-26610e07f840/strainphlan_src/:;&amp;#39;)
export R_LIBS=/mnt/software/unstowable/anaconda/envs/metagenomics/lib/R/library
export BOWTIE2_INDEXES=/mnt/genomeDB/misc/softwareDB/metaphlan/huttenhower.sph.harvard.edu/metaphlan/bowtie2db/

## Kraken2
export OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/opt/gcc-4.9.3/lib64:$LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;deactivate.denv_vars.sh&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;&lt;code&gt;deactivate.d/env_vars.sh&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;#!/bin/sh

export PATH=$OLD_PATH
export R_LIBS=
export BOWTIE2_INDEXES=
export LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在旧版的Anaconda中，&lt;code&gt;source deactivate&lt;/code&gt;默认会把&lt;code&gt;PATH&lt;/code&gt;变量中的第一个目录删掉，所以上面使用了&lt;code&gt;sed&lt;/code&gt;来把新目录插到第二个的位置。现在的conda版本(使用&lt;code&gt;conda deactivate&lt;/code&gt;)好像不存在这样的问题了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&#34; class=&#34;uri&#34;&gt;https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Emacs远程连接R</title>
      <link>/post/2018-11-25-emacs-remote-r/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-11-25-emacs-remote-r/</guid>
      <description>&lt;section id=&#34;r&#34; class=&#34;level2&#34;&gt;
&lt;h2&gt;本地的R脚本，远程执行&lt;/h2&gt;
&lt;p&gt;从事生信工作，已经形成了对R语言的重度依赖，Rstudio作为专注于R的IDE拥有强大的优势，但是我还是更习惯于Emacs的ESS的操作。其实之前就遇到过一个挺有意思的问题，如何用本地的Emacs去编辑并执行服务器上的R脚本。一个很显而易见的方法就是用Emacs的Tramp SSH连接到服务器，打开R脚本，这个时候ESS会自动使用远程服务器的R来运行。但是问题来了，在画图的时候这个远程的R进程并不能通过X11把图传回，所以会自动存储为Rplot.pdf于工作目录。Google了很久，找到了以解决方案：&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;打开本地shell/eshell (M-x shell/eshell)&lt;/li&gt;
&lt;li&gt;在打开的shell中连接远程服务器（ssh -X &lt;a href=&#34;mailto:user@remote.machine.ip&#34;&gt;user@remote.machine.ip&lt;/a&gt; 或 ssh -Y）并运行R&lt;/li&gt;
&lt;li&gt;使用ESS remote（M-x ess-remote）&lt;/li&gt;
&lt;li&gt;打开本地或远程（Tramp mode）的R脚本&lt;/li&gt;
&lt;li&gt;使用C-c C-n（在CUA mode关闭情况下可使用C-Enter）或C-c C-c逐行或区域执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述过程中，顺序其实不是很重要，唯一需要注意的是如果R脚本在服务器上，一定要先开启一个本地的shell，要不然Emacs会默认使用远程机器的shell。&lt;/p&gt;
&lt;p&gt;为了简化此过程，我写了一个函数并把它定义给快捷键C-c C-r（写在init.el或.emacs文件中）：&lt;/p&gt;
&lt;pre class=&#34;lisp&#34;&gt;&lt;code&gt;(defun spawn-ess-remote (login)
  &amp;quot;connect to remote server and open ssh&amp;quot;
  (interactive &amp;quot;sUser login (uname@server.ip): &amp;quot;)
  (pop-to-buffer (get-buffer-create (generate-new-buffer-name &amp;quot;Remote-R&amp;quot;)))
  (shell (current-buffer))
  (process-send-string nil (format&amp;quot;ssh -Y %s \n&amp;quot; login) )
  (process-send-string nil &amp;quot;R\n&amp;quot;)
  (ess-remote nil &amp;quot;R&amp;quot;))
(global-set-key (kbd &amp;quot;C-c C-r&amp;quot;) &amp;#39;spawn-ess-remote)
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Frequently Googled Questions</title>
      <link>/post/2018-09-05-bioinfo-cheatsheet/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-09-05-bioinfo-cheatsheet/</guid>
      <description>&lt;div id=&#34;linux&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Linux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Extract (decompress) with a file pattern (wildcard) &lt;a href=&#34;https://superuser.com/questions/504798/extract-specific-files-in-a-tar-archive-using-a-wildcard&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;sh&#34;&gt;&lt;code&gt;tar -xf MyTar.tar --wildcards &amp;quot;*.jpg&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ggplot2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;ggplot2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;rotate axis label &lt;a href=&#34;https://stackoverflow.com/questions/1330989/rotating-and-spacing-axis-labels-in-ggplot2&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;remove legend title &lt;a href=&#34;http://www.cookbook-r.com/Graphs/Legends_%28ggplot2%29/#hiding-the-legend-title&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Remove title for fill legend
p + 
  guides(fill=guide_legend(title=NULL))

# Remove title for all legends
p + 
  theme(legend.title=element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;legends in multiple columns/rows &lt;a href=&#34;https://ggplot2.tidyverse.org/reference/guide_legend.html&#34;&gt;ref&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A lot of interesting and useful things in this ref&lt;/li&gt;
&lt;li&gt;overriding the alpha value&lt;/li&gt;
&lt;li&gt;customizing the legend text angle&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p + 
  guides(col = guide_legend(nrow = 8))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
